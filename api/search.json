[{"id":"781fa3590e4bcb002d36df9bb0176caa","title":"JS高级-5-面向对象编程-2","content":"JS高级-5-面向对象编程-2","slug":"js-premier-5-object-oriented-programming-2","date":"2025-07-31T06:41:18.000Z","categories_index":"工作","tags_index":"前端,技术,JavaScript,笔记,进阶,面向对象编程,OOP,原型链,继承,类","author_index":"Proselyte"},{"id":"2c9152db5ab3b447eb6957f90810b68a","title":"React钩子函数-1-useState和useReducer","content":"React钩子函数-1-useState和useReducer一、背景与概述这两个钩子函数归纳为 State Hook。\n状态帮助组件 “记住”用户输入的信息。例如，一个表单组件可以使用状态存储输入值，而一个图像库组件可以使用状态存储所选的图像索引。\n\n使用 useState 声明可以直接更新的状态变量。\n使用 useReducer 在 reducer 函数 中声明带有更新逻辑的 state 变量。\n\n在正式学习前，你有必要了解 React 中的 渲染和提交 这一基本但重要的概念。\n渲染和提交组件显示到屏幕之前，其必须被 React 渲染。\n想象一下，你的组件是厨房里的厨师，把食材烹制成美味的菜肴。在这种场景下，React 就是一名服务员，他会帮客户们下单并为他们送来所点的菜品。这种请求和提供 UI 的过程总共包括三个步骤：\n\n触发 一次渲染（把客人的点单分发到厨房）\n渲染 组件（在厨房准备订单）\n提交 到 DOM（将菜品放在桌子上）\n\n步骤 1: 触发一次渲染有两种原因会导致组件的渲染:\n\n组件的 初次渲染。\n组件（或者其祖先之一）的 状态发生了改变。\n\n初次渲染当应用启动时，会触发初次渲染。框架和沙箱有时会隐藏这部分代码，但它是通过调用 createRoot 方法并传入目标 DOM 节点，然后用你的组件调用 render 函数完成的：\n12345import Image from './Image.js';import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'))root.render(&lt;Image /&gt;);\n\n状态更新时重新渲染一旦组件被初次渲染，你就可以通过使用 set 函数 更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。（你可以把这种情况想象成餐厅客人在第一次下单之后又点了茶、点心和各种东西，具体取决于他们的胃口。）\n步骤 2: React 渲染你的组件在你触发渲染后，React 会调用你的组件来确定要在屏幕上显示的内容。“渲染中” 即 React 在调用你的组件。\n\n在进行初次渲染时, React 会调用根组件。\n对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。\n\n这个过程是递归的：如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染那个组件，而如果那个组件又返回了某个组件，那么 React 接下来就会渲染那个组件，以此类推。这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止。\n注意：渲染必须始终是一次 纯计算\n\n输入相同，输出相同。 给定相同的输入，组件应始终返回相同的 JSX。（当有人点了西红柿沙拉时，他们不应该收到洋葱沙拉！）\n只做它自己的事情。 它不应更改任何存在于渲染之前的对象或变量。（一个订单不应更改其他任何人的订单。）\n\n否则，随着代码库复杂性的增加，你可能会遇到令人困惑的错误和不可预测的行为。在 “严格模式” 下开发时，React 会调用每个组件的函数两次，这可以帮助发现由不纯函数引起的错误。\n步骤 3: React 把更改提交到 DOM 上在渲染（调用）你的组件之后，React 将会修改 DOM。\n\n对于初次渲染，React 会使用 appendChild() DOM API 将其创建的所有 DOM 节点放在屏幕上。\n对于重渲染，React 将应用最少的必要操作（在渲染时计算！），以使得 DOM 与最新的渲染输出相互匹配。\n\nReact 仅在渲染之间存在差异时才会更改 DOM 节点。 例如，有一个组件，它每秒使用从父组件传递下来的不同属性重新渲染一次。注意，你可以添加一些文本到 &lt;input&gt; 标签，更新它的 value，但是文本不会在组件重渲染时消失。\n尾声：浏览器绘制在渲染完成并且 React 更新 DOM 之后，浏览器就会重新绘制屏幕。尽管这个过程被称为“浏览器渲染”（“browser rendering”），但我们还是将它称为“绘制”（“painting”），以避免在这些文档的其余部分中出现混淆。\n二、useState引入 useStateuseState 是一个 React Hook，它允许你向组件添加一个状态变量(state)。\n组件通常需要根据交互更改屏幕上显示的内容。输入表单应该更新输入字段，单击轮播图上的“下一个”应该更改显示的图片，单击“购买”应该将商品放入购物车。组件需要“记住”某些东西：当前输入值、当前图片、购物车。在 React 中，这种组件特有的记忆被称为 state。\n1234567891011121314// 需要引入 state 的情景// 如果不使用 state 不能正常更新变量export default function Foo() {  let index = 0;  function handleClick() {    index = index + 1;  }  return (    &lt;&gt;      &lt;button onClick={handleClick}&gt;Next&lt;/button&gt;      &lt;p&gt;{index}&lt;/p&gt;    &lt;/&gt;  );}\n\nhandleClick() 事件处理函数正在更新局部变量 index。但存在两个原因使得变化不可见：\n\n局部变量无法在多次渲染中持久保存。 当 React 再次渲染这个组件时，它会从头开始渲染——不会考虑之前对局部变量的任何更改。\n更改局部变量不会触发渲染。 React 没有意识到它需要使用新数据再次渲染组件。\n\n要使用新数据更新组件，需要做两件事：\n\n保留 渲染之间的数据。\n触发 React 使用新数据渲染组件（重新渲染）。\n\nuseState Hook 提供了这两个功能：\n\nState 变量 用于保存渲染间的数据。\nState setter 函数 更新变量并触发 React 再次渲染组件。\n\n123// 使用 useState Hookimport React, { useState } from 'react';const [state, setState] = useState(initialState);\n\nuseState(initialState)在组件的顶层调用 useState 来声明一个 状态变量。按照惯例使用 数组解构 来命名状态变量，例如 [something, setSomething]。\n参数：\n\ninitialState：你希望 state 初始化的值。它可以是任何类型的值，但对于函数有特殊的行为。在初始渲染后，此参数将被忽略。如果传递函数作为 initialState，则它将被视为 初始化函数。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。\n\n返回：\nuseState 返回一个由两个值组成的数组：\n\n当前的 state。在首次渲染时，它将与你传递的 initialState 相匹配。\nset 函数，它可以让你将 state 更新为不同的值并触发重新渲染。\n\n注意事项：\n\nuseState 是一个 Hook，因此你只能在组件的顶层或自己的 Hook 中调用它。你不能在循环或条件语句中调用它。如果你需要这样做，请提取一个新组件并将状态移入其中。\n在严格模式中，React 将两次调用初始化函数，以帮你找到意外的不纯性。这只是开发时的行为，不影响生产。如果你的初始化函数是纯函数（本该是这样），就不应影响该行为。其中一个调用的结果将被忽略。\n\nset 函数，例如 setSomething(nextState)useState 返回的 set 函数允许你将 state 更新为不同的值并触发重新渲染。你可以直接传递新状态，也可以传递一个根据先前状态来计算新状态的函数。\n参数：\n\nnextState：你想要 state 更新为的值。它可以是任何类型的值，但对于函数有特殊的行为。\n如果你将函数作为 nextState 传递，它将被视为更新函数。它必须是纯函数，只接受待定的 state 作为其唯一参数，并应返回下一个状态。React 将把你的更新函数放入队列中并重新渲染组件。在下一次渲染期间，React 将通过把队列中所有更新函数应用于先前的状态来计算下一个状态。\n\n\n\n返回值：\nset 函数没有返回值。\n注意事项：\n\nset 函数 仅更新下一次渲染的状态变量。如果在调用 set 函数后读取状态变量，则仍会得到在调用之前显示在屏幕上的旧值。\n如果你提供的新值与当前 state 相同（由 Object.is 比较确定），React 将跳过重新渲染该组件及其子组件。这是一种优化。虽然在某些情况下 React 仍然需要在跳过子组件之前调用你的组件，但这不应影响你的代码。\nReact 会 批量处理状态更新。它会在所有 事件处理函数运行 并调用其 set 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。在某些罕见情况下，你需要强制 React 更早地更新屏幕，例如访问 DOM，你可以使用 flushSync。\nset 函数具有稳定的标识，所以你经常会看到 Effect 的依赖数组中会省略它，即使包含它也不会导致 Effect 重新触发。如果 linter 允许你省略依赖项并且没有报错，那么你就可以安全地省略它。\n在渲染期间，只允许在当前渲染组件内部调用 set 函数。React 将丢弃其输出并立即尝试使用新状态重新渲染。这种方式很少需要，但你可以使用它来存储先前渲染中的信息。\n在严格模式中，React 将两次调用你的更新函数，以帮助你找到意外的不纯性。这只是开发时的行为，不影响生产。如果你的更新函数是纯函数（本该是这样），就不应影响该行为。其中一次调用的结果将被忽略。\n\n12345678// 使用 useState 对上例进行修改import React, { useState } from 'react';// ...const [index, setIndex] = useState(0);function handleClick() {  setIndex(index + 1);}// ...\n\n\n组件进行第一次渲染。 因为你将 0 作为 index 的初始值传递给 useState，它将返回 [0, setIndex]。 React 记住 0 是最新的 state 值。\n你更新了 state。当用户点击按钮时，它会调用 setIndex(index + 1)。 index 是 0，所以它是 setIndex(1)。这告诉 React 现在记住 index 是 1 并触发下一次渲染。\n组件进行第二次渲染。React 仍然看到 useState(0)，但是因为 React 记住 了你将 index 设置为了 1，它将返回 [1, setIndex]。以此类推！\n\nstate 的特性你可以在一个组件中拥有任意多个、多种类型的 state 变量。\nState 是隔离且私有的State 是屏幕上组件实例内部的状态。换句话说，如果你渲染同一个组件两次，每个副本都会有完全隔离的 state！改变其中一个不会影响另一个。\n这就是 state 与声明在模块顶部的普通变量不同的原因。 State 不依赖于特定的函数调用或在代码中的位置，它的作用域“只限于”屏幕上的某块特定区域。\nstate 完全私有于声明它的组件。父组件无法更改它。这使你可以向任何组件添加或删除 state，而不会影响其他组件。\n而如果你希望多个拥有相同组件的副本共享 state，你可以将 state 提升到它们的共同父组件中，即将相关 state 从这两个组件上移除，并把 state 放到它们的公共父级，再通过 props 将 state 传递给这两个组件。这被称为“状态提升”。\n对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 state。这一原则也被称为拥有 “可信单一数据源”。它并不意味着所有状态都存在一个地方——对每个状态来说，都需要一个特定的组件来保存这些状态信息。你应该 将状态提升 到公共父级，或 将状态传递 到需要它的子级中，而不是在组件之间复制共享的状态。\nstate 如同一张快照也许 state 变量看起来和一般的可读写的 JavaScript 变量类似。但 state 在其表现出的特性上更像是一张快照。设置它不会更改你已有的 state 变量，但会触发重新渲染。\n设置 state 会触发渲染。你可能会认为你的用户界面会直接对点击之类的用户输入做出响应并发生变化。在 React 中，它的工作方式与这种思维模型略有不同。在上一页中，你看到了来自 React 的设置 state 请求重新渲染。这意味着要使界面对输入做出反应，你需要设置其 state。\n“正在渲染” 就意味着 React 正在调用你的组件——一个函数。你从该函数返回的 JSX 就像是在某个时间点上 UI 的快照。它的 props、事件处理函数和内部变量都是 根据当前渲染时的 state 被计算出来的。\n与照片或电影画面不同，你返回的 UI “快照”是可交互的。它其中包括类似事件处理函数的逻辑，这些逻辑用于指定如何对输入作出响应。React 随后会更新屏幕来匹配这张快照，并绑定事件处理函数。因此，按下按钮就会触发你 JSX 中的点击事件处理函数。\n当 React 重新渲染一个组件时：\n\nReact 会再次调用你的函数\n函数会返回新的 JSX 快照\nReact 会更新界面以匹配返回的快照\n\n一个 state 变量的值永远不会在一次渲染的内部发生变化，即使其事件处理函数的代码是异步的。它的值在 React 通过调用你的组件“获取 UI 的快照”时就被“固定”了。\nstate 的“批处理”React 会等到事件处理函数中的所有代码都运行完毕再处理你的 state 更新。\n这让你可以更新多个 state 变量——甚至来自多个组件的 state 变量——而不会触发太多的重新渲染。但这也意味着只有在你的事件处理函数及其中任何代码执行完成 之后，UI 才会更新。这种特性也就是批处理，它会使你的 React 应用运行得更快。它还会帮你避免处理只​​更新了一部分 state 变量的令人困惑的“半成品”渲染。\nReact 不会跨多个需要刻意触发的事件（如点击）进行批处理——每次点击都是单独处理的。请放心，React 只会在一般来说安全的情况下才进行批处理。这可以确保，例如，如果第一次点击按钮会禁用表单，那么第二次点击就不会再次提交它。\n利用这一特性，可以实现在下次渲染前多次更新同一个 state，这将使用更新函数来实现，后文的“根据先前的 state 更新 state”部分将详细说明。\n对 state 进行保留和重置各个组件的 state 是各自独立的。根据组件在 UI 树中的位置，React 可以跟踪哪些 state 属于哪个组件。你可以控制在重新渲染过程中何时对 state 进行保留和重置。\n状态与渲染树中的位置相关。状态是由 React 保存的。React 通过组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。React 在移除一个组件时，也会销毁它的 state。只要一个组件还被渲染在 UI 树的相同位置，React 就会保留它的 state。如果它被移除，或者一个不同的组件被渲染在相同的位置，那么 React 就会丢掉它的 state。\n相同位置的相同组件会使得 state 被保留下来。记住对 React 来说重要的是组件在 UI 树中的位置,而不是在 JSX 中的位置！React 不知道你的函数里是如何进行条件判断的，它只会“看到”你返回的树。\n相同位置的不同组件会使 state 重置。并且，当你在相同位置渲染不同的组件时，组件的整个子树都会被重置。\n一般来说，如果你想在重新渲染时保留 state，几次渲染中的树形结构就应该相互“匹配”。结构不同就会导致 state 的销毁，因为 React 会在将一个组件从树中移除时销毁它的 state。永远要将组件定义在最上层并且不要把它们的定义嵌套起来。\n在相同位置重置 state。有两个方法可以在它们相互切换时重置 state：\n\n将组件渲染在不同的位置。这个解决方案在你只有少数几个独立的组件渲染在相同的位置时会很方便。\n使用 key 赋予每个组件一个明确的身份。请记住 key 不是全局唯一的。它们只能指定父组件内部的顺序。使用 key 来重置 state 在处理表单时特别有用。\n\nstate 的构建原则构建良好的 state 可以让组件变得易于修改和调试，而不会经常出错。以下是你在构建 state 时应该考虑的一些建议。\n\n合并关联的 state。如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。\n避免互相矛盾的 state。当 state 结构中存在多个相互矛盾或“不一致”的 state 时，你就可能为此会留下隐患。应尽量避免这种情况。\n避免冗余的 state。如果你能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。\n避免重复的 state。当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。\n避免深度嵌套的 state。深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 错误示例// 矛盾的 stateconst [isSending, setIsSending] = useState(false);const [isSent, setIsSent] = useState(false);//因为 isSending 和 isSent 不应同时为 true，所以最好用一个 status 变量来代替它们，这个 state 变量可以采取三种有效状态其中之一：'typing' (初始), 'sending', 和 'sent'// 冗余的 stateconst [firstName, setFirstName] = useState('');const [lastName, setLastName] = useState('');const [fullName, setFullName] = useState('');// 这个表单有三个 state 变量：firstName、lastName 和 fullName。然而，fullName 是多余的。在渲染期间，你始终可以从 firstName 和 lastName 中计算出 fullName，因此需要把它从 state 中删除。// 重复的 stateconst [items, setItems] = useState(initialItems);const [selectedItem, setSelectedItem] = useState(items[0]);// selectedItem 的内容与 items 列表中的某个项是同一个对象。 这意味着关于该项本身的信息在两个地方产生了重复。简单的解决方法是消除重复项，使用 index 创建索引。const [selectedIndex, setSelectedIndex] = useState(0); // 正确做法，避免重复// 深度嵌套的 stateexport const initialTravelPlan = {  id: 0,  title: '(Root)',  childPlaces: [{    id: 1,    title: 'Earth',    childPlaces: [{      id: 2,      title: 'Africa',      childPlaces: [{        id: 3,        title: 'Botswana',        childPlaces: []      }, {        id: 4,        title: 'Egypt',        childPlaces: []      }, {        id: 5,        title: 'Kenya',        childPlaces: []      }, {        id: 6,        title: 'Madagascar',        childPlaces: []      }]    }]  }]}// 这个 state 变量的结构很深。更新它需要多次嵌套的映射和过滤操作。更好的做法是使用扁平化的结构。//不同于树状结构，每个节点的 place 都是一个包含 其子节点 的数组，你可以让每个节点的 place 作为数组保存 其子节点的 ID。然后存储一个节点 ID 与相应节点的映射关系。// 扁平化后的 stateexport const initialTravelPlan = {  0: {    id: 0,    title: '(Root)',    childIds: [1, 42, 46],  },  1: {    id: 1,    title: 'Earth',    childIds: [2, 10, 19, 26, 34]  },  2: {    id: 2,    title: 'Africa',    childIds: [3, 4, 5, 6 , 7, 8, 9]  },   3: {    id: 3,    title: 'Botswana',    childIds: []  },  4: {    id: 4,    title: 'Egypt',    childIds: []  },  5: {    id: 5,    title: 'Kenya',    childIds: []  },  6: {    id: 6,    title: 'Madagascar',    childIds: []  }}// 说明：由于原例代码过长，仅展示部分，以演示效果\n\nuseState 的使用为组件添加状态在组件的顶层调用 useState 来声明一个或多个状态变量。React 会存储新状态，使用新值重新渲染组件，并更新 UI。\n根据先前的 state 更新 state要想根据先前的 state 更新 state，你可以将一个函数作为 nextState 传递给 set 函数。这个函数会接收当前的 state 作为参数，并返回新的 state。这个函数称为更新函数。\n假设 age 为 42，点击事件触发三次 set 函数：\n1234567891011121314function handleClick1() {  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)  setAge(age + 1); // setAge(42 + 1)  // 结果：age = 43}function handleClick2() {  setAge(a =&gt; a + 1); // setAge(42 =&gt; 43)  setAge(a =&gt; a + 1); // setAge(43 =&gt; 44)  setAge(a =&gt; a + 1); // setAge(44 =&gt; 45)  // 结果：age = 45}// 应该使用下面示例的更新函数来确保每次更新都基于最新的 state。\n\n更新状态中的对象和数组你可以将对象和数组放入状态中。在 React 中，状态被认为是只读的，因此 你应该使用 set 函数替换它而不是简单使用 = 来改变现有对象。\n避免重复创建初始状态React 只在初次渲染时保存初始状态，后续渲染时将其忽略。\n1234function TodoList() {  const [todos, setTodos] = useState(createInitialTodos());  // ...}\n\n尽管 createInitialTodos() 的结果仅用于初始渲染，但你仍然在每次渲染时调用此函数。如果它创建大数组或执行昂贵的计算，这可能会浪费资源。\n为了解决这个问题，你可以将它作为初始化函数传递给 useState：\n1234function TodoList() {  const [todos, setTodos] = useState(createInitialTodos);  // ...}\n\n请注意，你传递的是 createInitialTodos 函数本身，而不是 createInitialTodos() 调用该函数的结果。如果将函数传递给 useState，React 仅在初始化期间调用它。\nReact 在开发模式下可能会调用你的初始化函数两次，以验证它们是否是纯函数。\n使用 key 重置状态你可以 通过向组件传递不同的 key 来重置组件的状态。在这个例子中，重置按钮改变 version 状态变量，我们将它作为一个 key 传递给 Form 组件。当 key 改变时，React 会从头开始重新创建 Form 组件（以及它的所有子组件），所以它的状态被重置了。\n12345678910111213141516import { useState } from 'react';export default function App() {  const [version, setVersion] = useState(0);  function handleReset() {    setVersion(version + 1);  }  return (    &lt;&gt;      &lt;button onClick={handleReset}&gt;Reset&lt;/button&gt;      &lt;Form key={version} /&gt; {/* key 变化时，Form 组件会被重新创建 */}    &lt;/&gt;  );}\n\n存储前一次渲染的信息通常情况下，你会在事件处理函数中更新状态。然而，在极少数情况下，你可能希望在响应渲染时调整状态——例如，当 props 改变时，你可能希望改变状态变量。\n在大多数情况下，你不需要这样做：\n\n如果你需要的值可以完全从当前 props 或其他 state 中计算出来，那么完全可以移除那些多余的状态。如果你担心重新计算的频率过高，可以使用 useMemo Hook 来帮助优化。\n如果你想重置整个组件树的状态，可以向组件传递一个不同的 key。\n如果可以的话，在事件处理函数中更新所有相关状态。\n\n在极为罕见的情况下，如果上述方法都不适用，你还可以使用一种方式，在组件渲染时调用 set 函数来基于已经渲染的值更新状态。\nuseState 疑难解答我已经更新了状态，但日志仍显示旧值调用 set 函数 不能改变运行中代码的状态：\n12345678910function handleClick() {  console.log(count);  // 0  setCount(count + 1); // 请求使用 1 重新渲染  console.log(count);  // 仍然是 0!  setTimeout(() =&gt; {    console.log(count); // 还是 0!  }, 5000);}\n\n这是因为状态表现为就像一个快照。更新状态会使用新的状态值请求另一个渲染，但并不影响在你已经运行的事件处理函数中的 count JavaScript 变量。\n如果你需要使用下一个状态，你可以在将其传递给 set 函数之前将其保存在一个变量中：\n12345const nextCount = count + 1;setCount(nextCount);console.log(count);     // 0console.log(nextCount); // 1\n\n我已经更新了状态，但是屏幕没有更新如果下一个状态等于先前的状态，React 将忽略你的更新。\n如果你修改了一个现有的 obj 对象并将其传递回 setObj，因此 React 忽略了更新。为了解决这个问题，你需要确保始终在状态中替换对象和数组，而不是对它们进行更改。\n出现错误：“Too many re-renders”React 会限制渲染次数，以防止进入无限循环。通常，这意味着在渲染期间无条件地设置状态，因此组件进入循环：渲染、设置状态（导致重新渲染）、渲染、设置状态（导致重新渲染）等等。通常，这是由错误地指定事件处理函数时引起的：\n12345678// 🚩 错误：在渲染过程中调用事件处理函数return &lt;button onClick={handleClick()}&gt;Click me&lt;/button&gt;// ✅ 正确：将事件处理函数传递下去return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;// ✅ 正确：传递一个内联函数return &lt;button onClick={(e) =&gt; handleClick(e)}&gt;Click me&lt;/button&gt;\n\n如果找不到这个错误的原因，请通过浏览器的检查工具，单击控制台中错误旁边的箭头，查看 JavaScript 堆栈以找到导致错误的具体 set 函数调用。\n初始化函数或更新函数运行了两次在严格模式下，React 会调用你的某些函数两次而不是一次，以帮助你发现意外的不纯性。您应该保证初始化函数、更新函数和组件函数是纯函数。\n事件处理函数不需要是纯粹的，所以 React 不会两次调用你的事件处理函数。\n我尝试将 state 设置为一个函数，但它却被调用了您不能像这样把函数放入状态：\n12345const [fn, setFn] = useState(someFunction);function handleClick() {  setFn(someOtherFunction);}\n\n因为你传递了一个函数，React 认为 someFunction 是一个初始化函数，而 someOtherFunction 是一个更新函数，于是它尝试调用它们并存储结果。要实际存储一个函数，你必须在两种情况下在它们之前加上 () =&gt;。然后 React 将存储你传递的函数。\n12345const [fn, setFn] = useState(() =&gt; someFunction);function handleClick() {  setFn(() =&gt; someOtherFunction);}\n\n二、useReducer引入 useReducer对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新逻辑整合到一个外部函数中，这个函数叫作 reducer。\n\n为什么称之为 reducer？它实际上是以数组上的 reduce() 方法命名的。reduce() 允许你将数组中的多个值 “累加” 成一个值：\n1234const arr = [1, 2, 3, 4, 5];const sum = arr.reduce(  (result, number) =&gt; result + number); // 1 + 2 + 3 + 4 + 5\n\n你传递给 reduce 的函数被称为 “reducer”。它接受 目前的结果 和 当前的值，然后返回 下一个结果。React 中的 reducer 和这个是一样的：它们都接受 目前的状态 和 action ，然后返回 下一个状态。这样，action 会随着时间推移累积到状态中。\n\nuseReducer 是一个 React Hook，它允许你向组件里面添加一个 reducer。它是处理状态的另一种方式。你可以通过三个步骤将 useState 迁移到 useReducer：\n\n将设置状态的逻辑 修改 成 dispatch 的一个 action；\n编写 一个 reducer 函数；\n在你的组件中 使用 reducer。\n\n12import React, { useReducer } from 'react';const [state, dispatch] = useReducer(reducer, initialArg, init?);\n\ndispatch 函数useReducer 返回的 dispatch 函数允许你更新 state 并触发组件的重新渲染。它需要传入一个 action 作为参数：\n123456const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() {  dispatch({ type: 'incremented_age' });  // ...}\n\nReact 会调用 reducer 函数以更新 state，reducer 函数的参数为当前的 state 与传递的 action。\n参数：\n\naction：用户执行的操作。可以是任意类型的值。通常来说 action 是一个对象，其中 type 属性标识类型，其它属性携带额外信息。\n\n返回值：\ndispatch 函数没有返回值。\n注意：\n\ndispatch 函数是为下一次渲染而更新 state。因此在调用 dispatch 函数后读取 state 并不会拿到更新后的值，也就是说只能获取到调用前的值。\n如果你提供的新值与当前的 state 相同（使用 Object.is 比较），React 会跳过组件和子组件的重新渲染，这是一种优化手段。虽然在跳过重新渲染前 React 可能会调用你的组件，但是这不应该影响你的代码。\nReact 会批量更新 state。state 会在 所有事件函数执行完毕 并且已经调用过它的 set 函数后进行更新，这可以防止在一个事件中多次进行重新渲染。如果在访问 DOM 等极少数情况下需要强制 React 提前更新，可以使用 flushSync。\n\n使用 useReducer这一部分将以下面的代码为例进行说明：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import { useState } from 'react';import AddTask from './AddTask.js';import TaskList from './TaskList.js';export default function TaskApp() {  const [tasks, setTasks] = useState(initialTasks); // tasks 逻辑较为复杂  function handleAddTask(text) {    setTasks([      ...tasks,      {        id: nextId++,        text: text,        done: false,      },    ]);  }  function handleChangeTask(task) {    setTasks(      tasks.map((t) =&gt; {        if (t.id === task.id) {          return task;        } else {          return t;        }      })    );  }  function handleDeleteTask(taskId) {    setTasks(tasks.filter((t) =&gt; t.id !== taskId));  }  return (    &lt;&gt;      &lt;h1&gt;布拉格的行程安排&lt;/h1&gt;      &lt;AddTask onAddTask={handleAddTask} /&gt;      &lt;TaskList        tasks={tasks}        onChangeTask={handleChangeTask}        onDeleteTask={handleDeleteTask}      /&gt;    &lt;/&gt;  );}let nextId = 3;const initialTasks = [  {id: 0, text: '参观卡夫卡博物馆', done: true},  {id: 1, text: '看木偶戏', done: false},  {id: 2, text: '打卡列侬墙', done: false},];\n\n第一步：将设置状态的逻辑修改成 dispatch 的一个 action移除所有的状态设置逻辑。只留下三个事件处理函数：\n\nhandleAddTask(text) 在用户点击 “添加” 时被调用。\nhandleChangeTask(task) 在用户切换任务或点击 “保存” 时被调用。\nhandleDeleteTask(taskId) 在用户点击 “删除” 时被调用。\n\n使用 reducer 管理状态与直接设置状态略有不同。它不是通过设置状态来告诉 React “要做什么”，而是通过事件处理程序 dispatch 一个 “action” 来指明 “用户刚刚做了什么”。（而状态更新逻辑则保存在其他地方！）因此，我们不再通过事件处理器直接 “设置 task”，而是 dispatch 一个 “添加/修改/删除任务” 的 action。这更加符合用户的思维。\n123456789101112131415161718192021function handleAddTask(text) {  dispatch({    type: 'added',    id: nextId++,    text: text,  });}function handleChangeTask(task) {  dispatch({    type: 'changed',    task: task,  });}function handleDeleteTask(taskId) {  dispatch({    type: 'deleted',    id: taskId,  });}\n\n你传递给 dispatch 的对象叫做 “action”。它是一个普通的 JavaScript 对象。它的结构是由你决定的，但通常来说，它应该至少包含可以表明 发生了什么事情 的信息。\n123456789function handleDeleteTask(taskId) {  dispatch(    // \"action\" 对象：    {      type: 'deleted',      id: taskId,    }  );}\n\n第二步：编写一个 reducer 函数reducer 函数就是你放置状态逻辑的地方。它接受两个参数，分别为当前 state 和 action 对象，并且返回的是更新后的 state：\n123function yourReducer(state, action) {  // 给 React 返回更新后的状态}\n\nReact 会将状态设置为你从 reducer 返回的状态。\n在这个例子中，要将状态设置逻辑从事件处理程序移到 reducer 函数中，你需要：\n\n声明当前状态（tasks）作为第一个参数；\n声明 action 对象作为第二个参数；\n从 reducer 返回 下一个 状态（React 会将旧的状态设置为这个最新的状态）。\n\n下面是所有迁移到 reducer 函数的状态设置逻辑：\n1234567891011121314151617181920212223242526272829function tasksReducer(tasks, action) {  switch (action.type) { // 使用 if-else 或 switch-case 均可，但后者是一般惯例    case 'added': {      return [        ...tasks,        {          id: action.id,          text: action.text,          done: false,        },      ];    }    case 'changed': {      return tasks.map((t) =&gt; {        if (t.id === action.task.id) {          return action.task;        } else {          return t;        }      });    }    case 'deleted': {      return tasks.filter((t) =&gt; t.id !== action.id);    }    default: {      throw Error('未知 action: ' + action.type);    }  }}\n\n由于 reducer 函数接受 state（tasks）作为参数，因此你可以 在组件之外声明它。这减少了代码的缩进级别，提升了代码的可读性。\n第三步：在组件中使用 reducer最后，你需要将 tasksReducer 导入到组件中。记得先从 React 中导入 useReducer Hook：\n1import { useReducer } from 'react';\n\n接下来，你就可以替换掉之前的 useState:\n12// const [tasks, setTasks] = useState(initialTasks);const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);\n\nuseReducer 和 useState 很相似——你必须给它传递一个初始状态，它会返回一个有状态的值和一个设置该状态的函数（在这个例子中就是 dispatch 函数）。但是，它们两个之间还是有点差异的。\n对比 useState 和 useReducerReducer 并非没有缺点！以下是比较它们的几种方法：\n\n代码体积： 通常，在使用 useState 时，一开始只需要编写少量代码。而 useReducer 必须提前编写 reducer 函数和需要调度的 actions。但是，当多个事件处理程序以相似的方式修改 state 时，useReducer 可以减少代码量。\n可读性： 当状态更新逻辑足够简单时，useState 的可读性还行。但是，一旦逻辑变得复杂起来，它们会使组件变得臃肿且难以阅读。在这种情况下，useReducer 允许你将状态更新逻辑与事件处理程序分离开来。\n可调试性： 当使用 useState 出现问题时, 你很难发现具体原因以及为什么。 而使用 useReducer 时， 你可以在 reducer 函数中通过打印日志的方式来观察每个状态的更新，以及为什么要更新（来自哪个 action）。 如果所有 action 都没问题，你就知道问题出在了 reducer 本身的逻辑中。 然而，与使用 useState 相比，你必须单步执行更多的代码。\n可测试性： reducer 是一个不依赖于组件的纯函数。这就意味着你可以单独对它进行测试。一般来说，我们最好是在真实环境中测试组件，但对于复杂的状态更新逻辑，针对特定的初始状态和 action，断言 reducer 返回的特定状态会很有帮助。\n个人偏好： 并不是所有人都喜欢用 reducer，没关系，这是个人偏好问题。你可以随时在 useState 和 useReducer 之间切换，它们能做的事情是一样的！\n\n如果你在修改某些组件状态时经常出现问题或者想给组件添加更多逻辑时，我们建议你还是使用 reducer。当然，你也不必整个项目都用 reducer，这是可以自由搭配的。你甚至可以在一个组件中同时使用 useState 和 useReducer。\n编写一个好的 reducer编写 reducer 时最好牢记以下两点：\n\nreducer 必须是纯粹的。 这一点和 状态更新函数 是相似的，reducer 是在渲染时运行的！（actions 会排队直到下一次渲染)。 这就意味着 reducer 必须纯净，即当输入相同时，输出也是相同的。它们不应该包含异步请求、定时器或者任何副作用（对组件外部有影响的操作）。它们应该以不可变值的方式去更新 对象 和 数组。\n每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化。 举个例子，如果用户在一个由 reducer 管理的表单（包含五个表单项）中点击了 重置按钮，那么 dispatch 一个 reset_form 的 action 比 dispatch 五个单独的 set_field 的 action 更加合理。如果你在一个 reducer 中打印了所有的 action 日志，那么这个日志应该是很清晰的，它能让你以某种步骤复现已发生的交互或响应。这对代码调试很有帮助！\n\n使用 Immer 简化 reducer与在平常的 state 中修改对象和数组一样，你可以使用 Immer 这个库来简化 reducer。在这里，useImmerReducer 让你可以通过 push 或 arr[i] = 来修改 state 。\nReducer 应该是纯净的，所以它们不应该去修改 state。而 Immer 为你提供了一种特殊的 draft 对象，你可以通过它安全地修改 state。在底层，Immer 会基于当前 state 创建一个副本。这就是通过 useImmerReducer 来管理 reducer 时，可以修改第一个参数，且不需要返回一个新的 state 的原因。\nuseReducer 疑难解答我已经 dispatch 了一个 action，但是打印出来仍然还是旧的 state调用 dispatch 函数 不会改变当前渲染的 state：\n12345678910function handleClick() {  console.log(state.age);  // 42  dispatch({ type: 'incremented_age' }); // 用 43 进行重新渲染  console.log(state.age);  // 还是 42！  setTimeout(() =&gt; {    console.log(state.age); // 一样是 42！  }, 5000);}\n\n这是因为 state 的行为和快照一样。更新 state 会使用新的值来对组件进行重新渲染，但是不会改变当前执行的事件处理函数里面 state 的值。\n如果你需要获取更新后的 state，可以手动调用 reducer 来得到结果：\n123456const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state);     // { age: 42 }console.log(nextState); // { age: 43 }\n\n我已经 dispatch 了一个 action，但是屏幕并没有更新React 使用 Object.is 比较更新前后的 state，如果 它们相等就会跳过这次更新。这通常是因为你直接修改了对象或数组：\n123456789101112131415function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 错误行为：直接修改对象      state.age++;      return state;    }    case 'changed_name': {      // 🚩 错误行为：直接修改对象      state.name = action.nextName;      return state;    }    // ...  }}\n\n你直接修改并返回了一个 state 对象，所以 React 会跳过这次更新。为了修复这个错误，你应该确保总是 使用正确的方式更新对象和数组：\n12345678910111213141516171819function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ 修复：创建一个新的对象      return {        ...state,        age: state.age + 1      };    }    case 'changed_name': {      // ✅ 修复：创建一个新的对象      return {        ...state,        name: action.nextName      };    }    // ...  }}\n\n在 dispatch 后 state 的某些属性变为了 undefined请确保每个 case 语句中所返回的新的 state 都复制了当前的属性：\n123456789function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        ...state, // 不要忘记复制之前的属性！        age: state.age + 1      };    }    // ...\n\n如果上面的代码没有 ...state ，返回的新的 state 就只有 age 属性。\n在 dispatch 后整个 state 都变为了 undefined如果你的 state 错误地变成了 undefined，可能是因为你忘记在某个分支返回 state，或者是你遗漏了某些 case 分支。可以通过在 switch 语句之后抛出一个错误来查找原因：\n1234567891011function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ...    }    case 'edited_name': {      // ...    }  }  throw Error('Unknown action: ' + action.type);}\n\n也可以通过使用 TypeScript 等静态检查工具来发现这类错误。\n我收到了一个报错：“Too many re-renders”这通常是在 渲染期间  dispatch 了 action 而导致组件进入了无限循环：dispatch（会导致一次重新渲染）、渲染、dispatch（再次导致重新渲染），然后无限循环。大多数这样的错误是由于事件处理函数中存在错误的逻辑：\n1234567// 🚩 错误：渲染期间调用了处理函数return &lt;button onClick={handleClick()}&gt;Click me&lt;/button&gt;// ✅ 修复：传递一个处理函数，而不是调用return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;// ✅ 修复：传递一个内联的箭头函数return &lt;button onClick={(e) =&gt; handleClick(e)}&gt;Click me&lt;/button&gt;\n\n如果你没有发现上述错误，在控制台点开报错旁边的箭头以查看错误堆栈，从中查找是哪个 dispatch 函数引发的错误。\n我的 reducer 和初始化函数运行了两次严格模式 下 React 会调用两次 reducer 和初始化函数，但是这不应该会破坏你的代码逻辑。\n这个 仅限于开发模式 的行为可以帮助你 保持组件纯粹：React 会使用其中一次调用结果并忽略另一个结果。如果你的组件、初始化函数以及 reducer 函数都是纯函数，这并不会影响你的逻辑。不过一旦它们存在副作用，这个额外的行为就可以帮助你发现它。\n比如下面这个 reducer 函数直接修改了数组类型的 state：\n12345678910function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // 🚩 错误：直接修改 state      state.todos.push({ id: nextId++, text: action.text });      return state;    }    // ...  }}\n\n因为 React 会调用 reducer 函数两次，导致你看到添加了两条代办事项，于是你就发现了这个错误行为。在这个示例中，你可以通过 返回新的数组而不是修改数组 来修复它：\n123456789101112131415function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // ✅ 修复：返回一个新的 state 数组      return {        ...state,        todos: [          ...state.todos,          { id: nextId++, text: action.text }        ]      };    }    // ...  }}\n\n现在这个 reducer 是纯函数了，调用两次也不会有不一致的行为。事件处理函数不需要实现为纯函数，并且 React 永远不会调用事件函数两次。\n三、总结钩子函数是 React 16.8 版本引入的一个重要特性，它允许在函数组件中使用状态和其他 React 特性。\n\n\n\n\n\n\n\n\n\nHook 可以帮助在组件中使用不同的 React 功能。你可以使用内置的 Hook 或使用自定义 Hook。\n此系列博客将对 React 钩子函数进行较为全面的整理，以及自定义钩子函数的写法与用途。主要将参考 React 官方文档、ChatGPT 或者 Copilot 补全以及B站或者油管上的视频。\n一方面本文档整合了官方文档中的多篇相关内容，避免您在频繁切换页面时思路混乱；另一方面，本文档也会对一些内容进行补充和扩展，以便您更好更全面地理解和使用这些钩子函数。\nuseState 和 useReducer 是两个常用的钩子函数，分别用于管理组件的状态和处理复杂的状态逻辑。\n参考文献：\n\nReact 内置 Hook - React 中文文档\nuseState - React 中文文档\nuseReducer - React 中文文档\nState：组件的记忆 - React 中文文档\n渲染和提交 - React 中文文档\nstate 如同一张快照\n选择 State 结构 - React 中文文档\n在组件间共享状态 - React 中文文档\n对 state 进行保留和重置 - React 中文文档\n迁移状态逻辑至 Reducer 中 - React 中文文档\n\n","slug":"react-hook-1-usestate-usereducer","date":"2025-07-30T02:52:16.000Z","categories_index":"工作","tags_index":"前端,技术,笔记,React,React Hook,钩子函数,useState,useReducer,官方文档","author_index":"Proselyte"},{"id":"b3a5751f5eb5e3e9873a3f7c71f06e93","title":"JS高级-5-面向对象编程-1","content":"JS高级-5-面向对象编程-1一、面向对象的理解面向对象是现实的抽象方式。对象是 JavaScript 中一个非常重要的概念，因为对象可以将多个相关联的数据封装到一起，更好地描述一个事物。\n用对象来描述事物，更有利于我们将现实的事物抽离成代码中的某个数据结构。\nJavaScript 支持多种编程范式，包括函数式编程和面向对象编程（OOP）。\n\n对象被设计成一组属性的无序组合，像是一个哈希表，由 key 和 value 组成。\nkey 是一个标识符的名称，value 可以是任意类型的数据，也可以是其他对象或者函数。\n如果一个值是一个函数，那么我们可以称之为对象的方法。\n\n如何创建一个对象：\n12var obj1 = new Object(); // 使用 Object 构造函数var obj2 = {}; // 使用对象字面量语法，是更加主流的方法\n\n二、对对象属性的操作12345678910111213141516171819202122var obj = {  name: 'Proselyte',  age: 18,}; // 对象示例// 访问属性console.log(obj.name); // Proselyteconsole.log(obj['age']); // 18// 修改属性obj.age = 20;// 删除属性delete obj.age;// 添加属性obj.address = '123 Main St';// 遍历属性for (var key in obj) {  console.log(key + ': ' + obj[key]);}\n\n三、对属性操作的控制如果我们想要对一个属性进行比较精准的控制，那么我们就使用属性描述符，使用 Object.defineProperty() 方法。Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n函数接收三个参数：\n\n第一个参数是要操作的对象。\n第二个参数是属性名。\n第三个参数是一个描述符对象，包含属性的特性。\n\n返回值为传递给函数的对象。\n属性描述符分类：\n\n数据属性（Data Properties）描述符（Descriptor）：\nvalue：属性的值。默认为undefined。\nwritable：一个布尔值，表示属性是否可以被修改。直接定义默认为true，通过属性描述符定义默认为false。\nenumerable：一个布尔值，表示属性是否可以被枚举（遍历）。直接定义默认为true，通过属性描述符定义默认为false。\nconfigurable：一个布尔值，表示属性是否可以被删除或修改。直接定义默认为true，通过属性描述符定义默认为false。该属性不可以被重定义。\n\n\n存取属性（Accessor Properties）描述符（Descriptor）：\nget：一个函数，当访问属性时调用。默认值为undefined。\nset：一个函数，当设置属性时调用。默认值为undefined。\nenumerable：一个布尔值，表示属性是否可以被枚举（遍历）。直接定义默认为true，通过属性描述符定义默认为false。\nconfigurable：一个布尔值，表示属性是否可以被删除或修改。直接定义默认为true，通过属性描述符定义默认为false。该属性不可以被重定义。\n\n\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 需求：对属性进行操作时有一些限制// 限制：不允许某属性被修改/删除/遍历// Object.defineProperty() 方法// 数据属性描述符var obj1 = {};Object.defineProperty(obj1, // 传入对象'name', //属性名，如果已有则修改，没有则添加{  value: 'Proselyte', // 属性值  writable: false, // 不允许修改  enumerable: false, // 不允许遍历  configurable: false, // 不允许删除});// 存取属性描述符// 1. 隐藏某一个私有属性不希望直接被外界使用和赋值// 2. 希望截获某一个属性来访问和设置值的过程时var obj2 = {};Object.defineProperty(obj2, // 传入对象'age', // 属性名{ // 存取描述符  get: function () {    // 此处可以执行更多操作    return 18; // 获取属性值  },  set: function (value) {    // 此处可以执行更多操作    console.log('设置年龄为：' + value); // 设置属性值时的操作  },  enumerable: true, // 可以遍历  configurable: true, // 可以删除或修改});// 定义多个属性描述符var obj = {  _age: 18, // 私有属性(通常以 _ 开头，但 JS 中没有真正严格意义上的私有属性)  // 另一种写法  set age(value) {    console.log('设置年龄为：' + value);    this._age = value;  },  get age() {    return this._age;  }};Object.defineProperties(obj, {  name: {    value: 'Proselyte',    writable: false,    enumerable: false,    configurable: false,  },  age: {    configurable: true,    enumerable: true,    get: function () {      return 18;    },    set: function (value) {      console.log('设置年龄为：' + value);    },  }})// 获取某一个特性属性的属性描述符console.log(Object.getOwnProjectDescriptor(obj, \"name\"));// 获取对象所有属性的属性描述符console.log(Object.getOwnPropertyDescriptors(obj));// Object的方法对对象的限制var obj = {  name: 'Proselyte',  age: 18,};// 禁止扩展属性Object.preventExtensions(obj); // 禁止扩展属性，不能添加新属性，但可以修改和删除现有属性obj.address = '123 Main St'; // 无效操作，不会报错，但不会添加// 冻结属性（Writable和 Configurable 都为 false）Object.freeze(obj); // 冻结对象，不能修改、删除或添加属性obj.name = 'New Name'; // 无效操作，不会报错，但不会修改delete obj.age; // 无效操作，不会报错，但不会删除\n\n四、创建对象的方案创建对象有多种方案，各有优缺点，适用于不同的场景。\n对象字面量适用于少量对象的创建，简单直接。但不适合创建大量对象或需要复用的情况。\n12345// 对象字面量var obj1 = {  name: 'Proselyte',  age: 18,};\n\n工厂模式适合创建多个相似对象，但无法区分不同具体类型的对象。\n1234567891011// 工厂模式function createPerson(name, age) {  return {    name: name,    age: age,  };}var person1 = createPerson('Proselyte', 18);var person2 = createPerson('Coder', 20);var person3 = createPerson('Developer', 22);\n\n构造函数通过 new 关键字调用函数，那么这个函数就是一个构造函数了。适合创建多个相似对象，并且可以通过 prototype 共享方法和属性。一般约定将构造函数的首字母大写。\n如果一个函数被使用 new 关键字调用，它会执行如下操作：\n\n在内存中创建一个新的空对象\n将这个空对象的原型指向构造函数的 prototype 属性\n将这个空对象赋值给 this\n执行函数体中的代码\n如果函数没有显式返回一个非空对象，则返回 this\n\n1234567891011121314151617// 构造函数模式function Person(name, age) {  this.name = name;  this.age = age;  this.sayHello = function () {    console.log('Hello, my name is ' + this.name);  };}var p1 = new Person('Proselyte', 18);console.log(p1); // Person { name: 'Proselyte', age: 18, sayHello: [Function] }var p2 = new Person('Coder', 20);console.log(p1.sayHello === p2.sayHello); // false，每个实例都有自己的 sayHello 方法// 但是其实没有必要，这样会浪费内存空间\n\n对象的原型JavaScript 中的对象是基于原型的。每个对象都有一个内部属性 [[Prototype]]，指向另一个对象，这个对象被称为原型。\n原型可以通过 Object.getPrototypeOf() 方法获取，也可以通过 __proto__ 属性访问。\n123456789101112131415161718// 对象的原型var obj = {  name: 'Proselyte',  age: 18,};// 每个对象中都有一个 [[prototype]] 属性，这个属性称为对象的原型（隐式原型）console.log(Object.getPrototypeOf(obj)); // {}console.log(obj.__proto__); // {}// 函数的原型// 函数也是对象，它也有一个 [[prototype]] 属性// 函数还多了一个原型属性 prototype（显式原型）function Foo {}var f = new Foo();console.log(f.__proto__ === Foo.prototype); // true，新对象的[[prototype]] 属性被赋值为构造函数的 prototype 属性\n\n\n当我们从对象中获取一个属性时，它会触发 [[get]] 操作。\n\n在当前对象中去查找对应的属性，如果找到就直接使用。\n如果没有找到，就会沿着它的原型链向上查找。\n\nprototype.constructor = 构造函数本身\n对原型的修改：\n12345678910111213141516171819202122232425function Person(name, age) {  this.name = name;  this.age = age;}// 修改 prototype 的部分属性Person.prototype.sayHello = function () {  console.log('Hello, my name is ' + this.name);};// 直接修改整个 prototype 对象Person.prototype = {  constructor: Person, // 可以在替换时就加上 constructor 属性  sayHello: function () {    console.log('Hello, my name is ' + this.name);  },};// 真实开发中添加 constructor 属性Object.defineProperty(Person.prototype, 'constructor', {  value: Person,  writable: false,  enumerable: false,  configurable: false,});\n\n原型和构造函数：\n12345678910// 将没有必要重复构造的函数的属性添加到原型中，而一般属性仍然添加到实例中function Person(name, age) {  this.name = name; // 实例属性  this.age = age; // 实例属性}// 在原型上添加方法，而不是每个对象都有自己的方法Person.prototype.sayHello = function () {  console.log('Hello, my name is ' + this.name);};\n\n五、总结面向对象编程是 JavaScript 中一个重要的编程范式，通过对象来组织代码和数据，可以更好地抽象化定义现实世界的事物。\n本文介绍了对象的基本概念、属性操作、属性描述符以及创建对象的不同方式。最重点的是创建对象方法中的原型和构造函数的使用。\n面向对象的第二篇将继续深入探讨原型链、继承以及类等其他面向对象编程的概念。\n参考内容：\n\ncoderwhy 最强 JavaScript 高级教程 57-69 集\n\n","slug":"js-premier-5-object-oriented-programming-1","date":"2025-07-28T10:18:47.000Z","categories_index":"工作","tags_index":"前端,技术,JavaScript,笔记,进阶,面向对象编程,OOP,原型,构造函数","author_index":"Proselyte"},{"id":"f6257aade18eefed38cc06dca4a6019e","title":"JS高级-4-函数式编程","content":"JS高级-4-函数式编程函数式编程（Functional Programming，简称FP）是一种编程范式，它强调使用纯函数、避免副作用、采用不可变数据以及函数的高阶特性来构建程序。与命令式编程不同，函数式编程更关注“计算的表达方式”和“函数的组合”。\n主要特点包括：\n\n纯函数：输出仅依赖输入，没有副作用。例如，函数不会修改外部状态。\n不可变数据：数据一旦创建就不能修改，任何“改变”都是返回新数据。\n高阶函数：函数是一等公民，可以将函数作为参数传递，或将函数作为返回值。\n函数组合：通过组合简单的函数构建复杂的逻辑。\n\n常见的函数式编程语言有：Haskell、Lisp、Scheme、Erlang、OCaml、F#以及一些支持函数式编程特性的语言，如：Python、JavaScript、Scala、Kotlin\n函数式编程的优势包括：\n\n代码更简洁、更易于理解和维护\n更好的并发性（由于无副作用）\n更容易测试\n\n一、纯函数纯函数的理解：\n副作用的理解：表示在执行一个函数时，除了返回值之外，还对调用函数产生了附加的影响，比如修改了全局变量、修改参数或者改变外部的存储。纯函数在执行的过程中不能产生副作用。副作用往往是产生bug的“温床”。\n1234567891011121314// 纯函数示例// slicevar arr = [1, 2, 3, 4, 5];var newArr = arr.slice(0, 3);console.log(newArr); // [1, 2, 3]console.log(arr); // [1, 2, 3, 4, 5]，原数组未改变// 非纯函数示例// splicevar arr1 = [1, 2, 3, 4, 5];var arr2 = arr1.splice(0, 3);console.log(arr2); // [1, 2, 3]console.log(arr1); // [4, 5]，原数组已改变\n\n纯函数的优势：\n\n安心地编写、安心地使用。\n写的时候保证了函数的纯度，只是实现自己的业务逻辑、不需要关心传入的内容是如何获取的或者依赖其他的外部变量是否以及发生了修改。\n用的时候确保输入内容不被任意修改，并且自己确定的输入一定会有确定的输出。\n\n\n\n\n\n\n\n\n\n\n所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。\n二、柯里化理解柯里化：\n1234567891011121314151617181920212223// 柯里化函数示例function add(a, b, c) {  return a + b + c;}var result = add(10, 20, 30);console.log(result); // 60function curriedAdd(x) {  return function(y) {    return function(z) {      return x + y + z;    };  };}var resultCurried = curriedAdd(10)(20)(30);console.log(resultCurried); // 60// 柯里化简写var curriedAddShort = x =&gt; y =&gt; z =&gt; x + y + z;var resultCurriedShort = curriedAddShort(10)(20)(30);console.log(resultCurriedShort); // 60\n\n为什么需要有柯里化？\n\n在函数式编程中，我们往往希望一个函数处理的问题尽可能地单一，而不是将一大堆的处理过程交给一个函数来处理。\n那么我们是否可以每次传入的参数在单一的函数中处理，处理完后在下一个函数中再使用处理后的结果。\n\n12345678910111213141516171819202122232425// 柯里化的单一职责原则function sum (x, y, z) {  x = x + 2; // 对 x 进行处理    return function (y) {    y = y + 3; // 对 y 进行处理        return function (z) {      z = z + 4; // 对 z 进行处理            return x + y + z; // 返回最终结果    };  }}// 之前高阶函数与闭包的示例也是柯里化function makeAdder(x) {  return function(y) {    return x + y;  };}var add5 = makeAdder(5);console.log(add5(10)); // 15console.log(add5(20)); // 25\n\n12345678910111213141516171819202122// 柯里化函数的实现// 编写统一转化的工具函数，而不必每次都手动编写function curry(fn) {  return function curried(...args) {    if (args.length &gt;= fn.length) {      return fn.apply(this, args);    }    return function(...args2) {      return curried.apply(this, args.concat(args2)); // 递归调用，直到参数数量满足 fn 的要求    };  };}function add(a, b, c) {  return a + b + c;}var curriedAdd = curry(add);console.log(curriedAdd(1)(2)(3)); // 6console.log(curriedAdd(1, 2)(3)); // 6console.log(curriedAdd(1, 2, 3)); // 6console.log(curriedAdd(1, 2, 3, 4)); // 6\n\n三、组合函数组合函数的概念：组合函数(Compose Function)是 JS 开发过程中一种对函数的使用技巧、模式。比如我们需要对某一个数据进行函数的调用，依次执行两个函数 fn1 和 fn2 。那么如果每次都需要手动调用这两个函数，代码会变得冗长且不易维护。组合函数可以将多个函数组合成一个新的函数，从而简化代码。\n1234567891011121314151617181920212223242526272829303132333435363738394041424344// 组合函数示例function double(num) {    return num * 2;}function square(num) {    return num * num;}var count = 10;var result = square(double(count));console.log(result); // 400，未使用组合函数function composeSimple(m, n) {    return function(count) {        return m(n(count)); // 先执行 n，再执行 m    };}var composedFunction = composeSimple(square, double);var resultComposed = composedFunction(count);console.log(resultComposed); // 400，使用组合函数// 通用组合函数实现function myCompose(...fns) {    var length = fns.length;    for (var i = 0; i &lt; length; i++) {        if (typeof fns[i] !== 'function') {            throw new TypeError('Expected a function');        }    }        function compose(...args) {        var index = 0;        var result = length ? fns[index].apply(this, args) : args;        while (++index &lt; length) {            result = fns[index].call(this, result);        }    }    return compose;}var composed = myCompose(double, square);console.log(composed(10)); // 400，使用通用组合函数\n\n四、其他知识补充with 语句with 语句扩展一个语句的作用域链。不建议使用 with 语句，因为它可能产生混淆错误和兼容性问题。\n12345678// with 语句示例// with 语句可以在指定的对象上创建一个作用域var obj = { a: 1, b: 2, c: 3 };with (obj) {  console.log(a + b + c); // 6}// with 语句会在当前作用域中查找变量，如果找不到则会查找全局作用域// 但不推荐使用 with 语句，因为它会降低代码的可读性和性能\n\neval 函数eval 是一个特殊的函数，它可以将传入的字符串当作 JavaScript 代码执行。\n123// eval 函数示例var jsString = 'console.log(\"Hello, World!\");';eval(jsString); // 输出 \"Hello, World!\"\n\n不建议在开发中使用 eval：\n\neval 代码的可读性很差。\neval 传入的参数是一个字符串，有可能在执行过程中被可以篡改，可能造成被攻击的风险。\neval 的执行必须经过 JS 解释器，不能被 JS 引擎优化，性能较差。\n\n严格模式在 ES5 标准中，JavaScript 引入了严格模式（Strict Mode）。它是一种具有限制性的 JavaScript 执行模式，从而使代码脱离了“松散（sloppy）模式”。支持严格模式的浏览器会以更加严格的方式对代码进行松散和执行。\n严格模式的主要特点：\n\n通过抛出错误来消除一些原有的静默（silent）错误。\n让 JS 引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）。\n禁用了在 ECMAScript 未来版本中可能会定义的一些语法。\n\n静默错误指虽然存在错误但是不会产生严重问题，因此不被抛出错误的情况。\n严格模式的开启：\n12// 在文件中开启严格模式use strict; // 在文件顶部声明\n\n12345// 在函数中开启严格模式function foo() {  'use strict'; // 在函数内部声明  // 函数体}\n\n严格模式的限制：\n\n无法意外地创建全局变量。\n会使静默失败的赋值操作抛出异常。\n试图删除不可删除的属性会抛出异常。\n不允许函数参数具有相同的名称。\n不允许 0 的八进制数字字面量。\n不允许使用 with 语句。\neval 不再为上层作用域创建变量。\nthis 绑定不会默认转成对象。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354use strict; // 开启严格模式// 1. 无法意外地创建全局变量function foo() {    globalVar = 10; // 抛出错误，无法创建全局变量}// 2. 静默失败的赋值操作抛出异常true.name = 'test'; // 静默错误抛出// 3. 删除不可删除的属性抛出异常function baz() {    var obj = {};    Object.defineProperty(obj, 'prop', {        value: 42,        configurable: false // 设置为不可配置    });    delete obj.prop; // 抛出错误，无法删除不可配置属性}// 4. 函数参数具有相同的名称会抛出异常function qux(a, a, b) { // 抛出错误，参数名重复    return a + b;}// 5. 不允许 0 的八进制数字字面量var octalError = 010; // 抛出错误，0 开头的数字字面量不再被视为八进制var octal = 0o10; // 正确的八进制表示法var decimal = 10; // 十进制表示法var hex = 0xA; // 十六进制表示法var binary = 0b1010; // 二进制表示法// 6. 不允许使用 with 语句function withExample() {    var obj = { a: 1, b: 2 };    with (obj) { // 抛出错误，with 语句在严格模式中不被允许        console.log(a + b);    }}// 7. eval 不再为上层作用域创建变量function evalExample() {    eval('var x = 10;'); // 抛出错误，eval 不会为上层作用域创建变量    console.log(x); // ReferenceError: x is not defined}// 8. this 绑定不会默认转成对象function thisExample() {    console.log(this); // undefined，而不是全局对象}thisExample();// setTimeOut 函数是特例，其中的 this 仍然指向全局对象\n\n五、总结函数式编程是一种强大的编程范式，它通过使用纯函数、不可变数据和高阶函数等特性来构建更简洁、更易于维护的代码。理解纯函数、柯里化和组合函数等概念，可以帮助我们更好地应用函数式编程的思想。\n此外，本文还补充了与函数相关的其他知识点，如严格模式、with 语句和 eval 函数等。\n参考内容：\n\ncoderwhy 最强 JavaScript 高级教程 45-56 集\n\n","slug":"js-premier-4-functional-programming","date":"2025-07-27T14:12:36.000Z","categories_index":"工作","tags_index":"前端,技术,JavaScript,笔记,进阶,函数式编程,纯函数,柯里化,组合函数","author_index":"Proselyte"},{"id":"0b480d0ac4115d2e3d40921ad7b91dbd","title":"JS高级-3-this关键字","content":"JS高级-3-this关键字一、this 的定义this 是 JavaScript 中的一个关键字，用于引用函数执行时的上下文对象。\n为什么需要this：\nthis指向什么：\nthis 的指向与函数的调用方式有关,而与定义方式无关。它可以指向不同的对象，具体取决于函数是如何被调用的。\n二、this 的绑定规则默认绑定当函数在全局作用域中调用时，即函数没有被绑定在某个对象上进行调用时，this 指向全局对象（在浏览器中是 window 对象）。\n1234567891011121314151617181920212223242526272829303132333435// 示例1function foo() {  console.log(this);}foo(); // 在浏览器中输出 window 对象// 示例2function test1() {  console.log(this);  test2();}function test2() {  console.log(this);  test3();}function test3() {  console.log(this);}test1(); // 在浏览器中输出 window 对象三次// 示例3function foo(func) {  func();}var obj = {  name: \"obj\",  bar: function () {    console.log(this);  },};foo(obj.bar); // 在浏览器中输出 window 对象\n\n隐式绑定通过某个对象进行调用，this 指向调用该函数的对象。\n123456789101112131415161718192021222324252627282930313233343536373839404142// 示例1function foo() {  console.log(this);}var obj = {  name: \"obj\",  foo: foo,};obj.foo(); // 输出 obj 对象// 示例2function foo() {  console.log(this);}var obj1 = {  name: \"obj1\",  foo: foo,};var obj2 = {  name: \"obj2\",  obj1: obj1,};obj2.obj1.foo(); // 输出 obj1 对象// 示例3function foo() {  console.log(this);}var obj1 = {  name: \"obj1\",  foo: foo,};var bar = obj1.foo; // 将 obj1 的 foo 赋值给 barbar(); // 默认绑定，输出 window 对象obj1.foo(); // 隐式绑定，输出 obj1 对象\n\n显式绑定\n\napply 和 call\n123456789// apply 和 call 的使用function foo() {  console.log(this);}var obj = {  name: \"obj\",};foo.apply(obj); // 输出 obj 对象foo.call(obj); // 输出 obj 对象\n\n\nfoo 直接调用和 call/apply 调用的区别在于 this 绑定的不同。foo 直接调用即默认绑定，this 指向全局对象，而 call/apply 调用则是显式绑定，this 指向传入的对象。\n\ncall 和 apply 的区别在于参数的传递方式。call 接受多个参数，而 apply 接受一个数组作为参数。\n123456789// call 和 apply 的区别function sum(a, b) {  return a + b;}var obj = {  name: \"obj\",};console.log(sum.call(obj, 1, 2)); // 输出 3console.log(sum.apply(obj, [1, 2])); // 输出 3\n\n\nbind\nbind 方法创建一个新的函数，这个函数在调用时会将 this 绑定到指定的对象上。\n123456789// bind 的使用function foo() {  console.log(this);}var obj = {  name: \"obj\",};var boundFoo = foo.bind(obj); // 创建一个新的函数，this 绑定到 objboundFoo(); // 此处不是默认绑定，而是显式绑定，输出 obj 对象\n\n自己实现 call、apply、bind (用js模拟实现)\n注意：我们的实现是练习函数、this、调用关系，不会过度考虑一些边界情况(edge case)。\n\ncall 实现：\n\n1234567891011121314151617181920212223242526// 给所有的函数添加一个 myCall 方法Function.prototype.myCall = function (thisArg, ...args) {  // 在这里可以去执行调用的那个函数(foo)  // 问题：如何获取调用函数的 this 指向？  // 1. 获取需要被执行的函数  var fn = this;    // 2. 对thisArg转成对象类型(防止传入的是非对象类型)  thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window; // 将 thisArg 转换为对象类型  // 3. 调用需要被执行的函数  thisArg.fn = fn; // 将 fn 绑定到 thisArg 上  thisArg.fn(...args); // 隐式绑定，this 指向 thisArg  delete thisArg.fn; // 删除临时添加的属性，避免污染 thisArg 对象};function foo() {  console.log(\"foo函数被执行\");}function sum(a, b) {  console.log(\"sum函数被执行\", a + b);}foo.myCall();sum.myCall(1, 2);\n\n\napply 实现：\n\n12345678910111213141516171819202122// 给所有的函数添加一个 myApply 方法Function.prototype.myApply = function (thisArg, argArray) {  // 1. 获取需要被执行的函数  var fn = this;  // 2. 对thisArg转成对象类型(防止传入的是非对象类型)  thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg) : window; // 将 thisArg 转换为对象类型  // 3. 调用需要被执行的函数  thisArg.fn = fn; // 将 fn 绑定到 thisArg 上  argArray = argArray || []; // 如果没有传入参数数组，则默认为空数组，因为对 undefined 展开会报错  var result = thisArg.fn(...argArray); // 隐式绑定，this 指向 thisArg  delete thisArg.fn; // 删除临时添加的属性，避免污染 thisArg 对象  return result;};function sum(a, b) {  console.log(\"sum函数被执行\", a + b);}sum.myApply(null, [1, 2]);\n\n\nbind 实现：\n\n1234567891011121314151617181920// 给所有的函数添加一个 myBind 方法Function.prototype.myBind = function (thisArg, ...args) {  // 1. 获取需要被执行的函数  var fn = this;    // 2. 对thisArg转成对象类型(防止传入的是非对象类型)  thisArg = (thisArg !== null &amp;&amp; thisArg !== undefined) ? Object(thisArg  ) : window; // 将 thisArg 转换为对象类型  // 3. 返回一个新的函数  function proxyFn (...innerArgs) {    // 在这里调用需要被执行的函数    thisArg.fn = fn; // 将 fn 绑定到 thisArg 上    var result = thisArg.fn(...args, ...innerArgs); // 隐式绑定，this 指向 thisArg。对两次传入的参数进行展开合并。    delete thisArg.fn; // 删除临时添加的属性    return result; // 返回函数执行结果  };  return proxyFn; // 返回新的函数};\n\nnew 绑定\n当使用 new 关键字调用一个函数时(构造器)，JavaScript 会创建一个新的对象，并将该对象作为 this 传递给函数。\n1234567891011// new 绑定的使用function Person(name, age) {  this.name = name;  this.age = age;}var p1 = new Person(\"Alice\", 25);console.log(p1.name, p1.age); // 输出 Alice 25var p2 = new Person(\"Bob\", 30);console.log(p2.name, p2.age); // 输出 Bob 30\n\n规则优先级\n默认绑定优先级最低，new 绑定优先级最高，显式绑定优先级高于隐式绑定。\n123456789101112131415161718192021222324// 显式绑定优先级高于隐式绑定// 示例1 call 与 applyvar obj = {  name: \"obj\",  foo: function () {    console.log(this);  },};obj.foo.call('abc'); // 输出 'abc'obj.foo.apply('abc'); // 输出 'abc'// 示例2 bindfunction foo() {  console.log(this);}var obj = {  name: \"obj\",  foo: foo.bind('abc'), // 使用 bind 显式绑定}obj.foo(); // 输出 'abc'\n\n1234567891011// new 绑定优先级高于显式绑定// new 关键字不能和 call/apply/bind 一起使用function foo() {  console.log(this);}var bar = foo.bind('abc'); // 使用 bind 显式绑定var obj = new bar(); // 使用 new 关键字调用console.log(obj); // 输出一个新对象，this 指向新对象而不是 'abc'\n\n部分内置函数的绑定\n\nsetTimeout：\n12345678910// setTimeout 的 this 绑定function foo() {  console.log(this);}var obj = {  name: \"obj\",};setTimeout(foo, 1000); // 输出 window 对象，因为 setTimeout 默认绑定setTimeout(foo.bind(obj), 1000); // 输出 obj 对象，因为使用了 bind 显式绑定// 由此可见，setTimeout 内部的 this 绑定是默认绑定，指向全局对象。\n\n监听点击事件：\n1234567891011// 监听点击事件的 this 绑定const boxDiv = document.querySelector('.box');boxDiv.addEventListener('click', function() {  console.log(this); // 输出 boxDiv 对象，因为 addEventListener 的回调函数是隐式绑定，this 指向触发事件的元素});boxDiv.onclick = function() {  console.log(this); // 输出 boxDiv 对象，因为 onclick 事件处理函数也是隐式绑定};boxDiv.addEventListener('click', function() {  console.log(this); // 同理为隐式绑定，输出 boxDiv 对象});\n\n数组.forEach/map/filter/find方法：\n12345678910111213// 数组的 forEach/map/filter 的 this 绑定const arr = [1, 2, 3];// forEach 的回调函数默认绑定arr.forEach(function(item) {  console.log(this); // 输出 window 对象，默认绑定});arr.forEach(function(item) {  console.log(this); // 输出 \"abc\"，传入的第二个参数即 this 指向}, \"abc\");// 其他数组方法同理\n\nthis规则之外\n忽略显式绑定：\napply/call/bind 绑定 null/undefined 时，this 指向全局对象（浏览器中为 window 对象）。\n1234567// 忽略显式绑定function foo() {  console.log(this);}foo.call(null); // 输出 window 对象foo.apply(undefined); // 输出 window 对象foo.bind(null)(); // 输出 window 对象\n\n间接函数引用：\n1234567891011121314151617181920212223242526272829303132333435363738var obj1 = {  name: \"obj1\",  foo: function() {    console.log(this);  }};var obj2 = {  name: \"obj2\"} // 此处未加分号// 正确使用obj2.bar = obj1.foo // 此时代码可以正常运行obj2.bar(); // 隐式绑定，输出 obj2 对象// 错误使用(obj2.bar = obj1.foo)(); // 报错 `TypeError: Cannot read properties of undefined (setting 'bar')`obj2.bar(); // 这是因为 obj2 声明时结尾没有分号，认为没有完成声明，从而将下面的代码与上面的合起来了//等价代码：// var obj2 = {//   name: \"obj2\"// }(obj2.bar = obj1.foo)();// 因此小括号不能乱加，分号也不是任何情况都可以省略(obj2.bar = obj1.foo)();// 如果 obj2 声明时结尾加了分号，这样使用相当于独立函数调用，输出 `window` 对象// 类似的另一个示例function foo(el) {  console.log(el, this.id);}var obj = {  id: \"obj\"} //此处未加分号[1, 2, 3].forEach(foo, obj); // 同样报错// 因为是使用 {id: \"obj\"}[1, 2, 3] 对象的forEach方法，而非我们期望的使用数组的forEach方法  \n\n三、arguments 对象123456789101112131415161718192021222324252627282930function foo(num1, num2, num3) {  // arguments 对象是一个类数组对象，包含了传递给函数的所有参数 (长得像数组，实质是对象)  console.log(arguments);  // 常见的对 arguments 对象的操作  // 1. 获取参数的长度  console.log(arguments.length); // 输出参数的个数  // 2. 根据索引值获取指定参数  console.log(arguments[0]); // 输出第一个参数  console.log(arguments[1]); // 输出第二个参数  // 3. callee 获取当前 arguments 对象所在的函数  console.log(arguments.callee); // 输出当前函数 foo 的引用  // arguments.callee(); 禁止这样使用，会形成递归调用，导致栈溢出错误。  // arguments 不具有 forEach、map、filter 等数组方法  // 自己遍历  var newArr1 = [];  for (var i = 0; i &lt; arguments.length; i++) {    newArr1.push(arguments[i]); // 将每个参数添加到新数组中  }  // arguments 转成 array 类型  var newArr2 = Array.prototype.slice.call(arguments); // 使用 Array.prototype.slice 将 arguments 转换为数组  var newArr3 = [].slice.call(arguments); // 使用空数组的 slice 方法将 arguments 转换为数组，与上一种方式本质上等价  var newArr4 = Array.from(arguments); // ES6 新增的 Array.from 方法}\n\n四、箭头函数箭头函数是ES6引入的一种新的函数定义方式，它比函数表达式更简洁。\n\n箭头函数没有自己的 this，它的 this 是从外部作用域继承的。\n箭头函数不会绑定this、arguments属性。\n箭头函数不能作为构造函数使用，不能使用 new 关键字调用。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 编写箭头函数// 1. () 参数// 2. =&gt; 箭头// 3. {} 函数体var arrowFunction = () =&gt; {  // 函数体};// 高阶函数在使用时，也可以传入箭头函数var nums = [1, 2, 3, 4, 5];nums.forEach((item, index, arr) =&gt; {  console.log(item); // 输出 1 2 3 4 5});// 常见的简写// 简写一：如果参数只有一个，可以省略括号nums.forEach(item =&gt; {  console.log(item); // 输出 1 2 3 4 5});// 简写二：如果函数体只有一行，可以省略大括号和 returnnums.forEach(item =&gt; console.log(item)); // 输出 1 2 3 4 5，并默认将函数体作为返回值，此处未undefinednums.filter(item =&gt; item % 2 === 0); // 输出 2 4，并将其作为返回值// 简写三：如果一个箭头函数，只有一行代码，且返回一个对象，在对象外面加小括号var bar = () =&gt; ({ name: \"bar\" });// 箭头函数的 this 绑定// 箭头函数没有自己的 this，它的 this 是从外部作用域继承的// 这意味着箭头函数中的 this 指向的是定义时的上下文，而不是调用时的上下文。//应用场景：var obj = {  name: \"obj\",  // 不使用箭头函数的做法，保存 this 的引用  getData: function() {    var _this = this;     setTimeout(() =&gt; {      var response = \"data from server\";      _this.data = response; // 正确用法，使用 _this 引用      this.data = response; // 错误用法，因为 setTimeout 是默认绑定， this 指向全局对象    }, 1000);  }  // 使用箭头函数的做法  getDataArrow: function() {    setTimeout(() =&gt; {      var response = \"data from server\";      this.data = response; // 正确用法，this 指向 obj 对象    }, 1000);  }};// 箭头函数没有自己的 arguments 对象，它会从外部作用域继承 arguments。// 示例：function foo() {  var bar = () =&gt; {    console.log(arguments); // 输出传入的参数，继承自 foo 的 arguments  };  return bar;}var fn = foo(1, 2, 3);fn(); // 输出 [1, 2, 3]，因为 bar 继承了 foo 的 arguments\n\n五、this 的面试题1234567891011121314151617181920// 题目1var name = \"window\";var person = {  name: \"person\",  sayName: function() {    console.log(this.name);  }};function sayName() {  var sss = person.sayName;  sss(); // 输出 \"window\"，独立函数调用  person.sayName(); // 输出 \"person\"，隐式绑定  (person.sayName)(); // 输出 \"person\"，隐式绑定，与上一行代码等价  (person.sayName = person.sayName)(); // 输出 \"window\"，独立函数调用  (person.sayName = person.sayName.bind(person))(); // 输出 \"person\"，显式绑定}sayName();\n\n123456789101112131415161718192021222324252627282930313233343536// 题目2var name = \"window\";var person1 = {  name: \"person1\",  foo1: function() {    console.log(this.name);  },  foo2: () =&gt; console.log(this.name),  foo3: function() {    return function () {      console.log(this.name);    }  },  foo4: function() {    return () =&gt; {      console.log(this.name);    }  }}var person2 = { name: \"person2\" }person1.foo1(); // person1，隐式绑定person1.foo1.call(person2); // person2，显式绑定person1.foo2(); // window，不绑定作用域，上层作用域是 windowperson1.foo2.call(person2); // window，箭头函数无显式绑定规则，上层作用域是 windowperson1.foo3()(); // window，独立函数调用person1.foo3.call(person2)(); // window，独立函数调用person1.foo3().call(person2); // person2，显式绑定person1.foo4()(); // person1，上层作用域是 person1person1.foo4.call(person2)(); // person2，上层作用域是 person2person1.foo4().call(person2); // person1，上层作用域是 person1，箭头函数无显式绑定规则\n\n12345678910111213141516171819202122232425262728293031323334353637// 题目3var name = \"window\";function Person(name) {  this.name = name;  this.foo1 = function() {    console.log(this.name);  };  this.foo2 = () =&gt; console.log(this.name),  this.foo3 = function() {    return function () {      console.log(this.name);    }  };  this.foo4 = function() {    return () =&gt; {      console.log(this.name);    }  }}var person1 = new Person(\"person1\");var person2 = new Person(\"person2\");person1.foo1(); // person1，隐式绑定person1.foo1.call(person2); // person2，显式绑定person1.foo2(); // person1，上层作用域是 person1person1.foo2.call(person2); // person1，箭头函数无显式绑定规则，上层作用域是 person1person1.foo3()(); // window，独立函数调用person1.foo3.call(person2)(); // window，独立函数调用person1.foo3().call(person2); // person2，显式绑定person1.foo4()(); // person1，上层作用域是 person1person1.foo4.call(person2)(); // person2，上层作用域是 person2person1.foo4().call(person2); // person1，上层作用域是 person1，箭头函数无显式绑定规则\n\n1234567891011121314151617181920212223242526272829303132// 题目4var name = \"window\";function Person(name) {  this.name = name;  this.obj = {    name: \"obj\",    foo1: function() {      return function() {        console.log(this.name);      }    },    foo2: function() {      return () =&gt; {        console.log(this.name);      }    }  }}var person1 = new Person(\"person1\");var person2 = new Person(\"person2\");person1.obj.foo1()(); // window，独立函数调用person1.obj.foo1.call(person2)(); // window，独立函数调用person1.obj.foo1().call(person2); // person2，显式绑定person1.obj.foo2()(); // obj，上层函数是由 person1.obj 调用的person1.obj.foo2.call(person2)(); // person2，上层作用域是 person2person1.obj.foo2().call(person2); // obj，上层函数是由 person1.obj 调用的，箭头函数无显式绑定规则// 注意：对象和代码块的区别，对象没有作用域而代码块有作用域。本题中 obj 是一个对象，没有作用域。函数有作用域。\n\n六、总结this 是 JavaScript 中的一个重要的关键字，用于引用函数执行时的上下文对象。它的指向与函数的调用方式有关，主要有默认绑定、隐式绑定、显式绑定和 new 绑定四种绑定规则，并给出了混合绑定时的优先级顺序。\n另外还补充了不符规则的几种特殊情况以及箭头函数、arguments等ES6新特性。\n总体来说这一块是有一定难度的，需要进行对比区分理解和练习，尤其是四种绑定规则之间的区分与优先级。\n参考内容：\n\ncoderwhy 最强 JavaScript 高级教程 23-44 集\n\n","slug":"js-premier-3-this-in-javascript","date":"2025-07-22T10:05:48.000Z","categories_index":"工作","tags_index":"前端,技术,JavaScript,面试,笔记,进阶,this,箭头函数,绑定规则,arguments,剩余参数","author_index":"Proselyte"},{"id":"44b8e9de277aafbb00bcc826b51452ad","title":"JS高级-2-高阶函数与闭包","content":"JS高级-2-高阶函数与闭包一、JS 中函数是一等公民在 JavaScript 中，函数被视为一等公民（First-Class Citizen），这意味着函数可以像其他数据类型一样被处理。具体来说，函数可以：\n\n作为变量赋值：函数可以被赋值给变量。\n1234const greet = function (name) {  return `Hello, ${name}!`;};console.log(greet(\"Alice\")); // 输出: Hello, Alice!\n\n作为参数传递：函数可以作为参数传递给其他函数。\n1234function executeFunction(fn, value) {  return fn(value);}console.log(executeFunction(greet, \"Bob\")); // 输出: Hello, Bob!\n\n作为返回值：函数可以从其他函数中返回。\n1234567function createGreeter(greeting) {  return function (name) {    return `${greeting}, ${name}!`;  };}const sayHello = createGreeter(\"Hello\");console.log(sayHello(\"Charlie\")); // 输出: Hello, Charlie!\n\n存储在数据结构中：函数可以存储在数组或对象中。\n12const functionsArray = [greet, sayHello];functionsArray.forEach((fn) =&gt; console.log(fn(\"Dave\"))); // 输出: Hello, Dave\n\n注意：函数名 Fn 是整个函数的引用，而 Fn()是执行该函数的返回值。\n二、高阶函数高阶函数是指接受一个或多个函数作为参数，或者返回一个函数的函数。高阶函数在 JavaScript 中非常常见，尤其是在处理数组和函数式编程时。\n开发者可以使用内置的高阶函数也可以自己编写高阶函数。\n常见的数组内置高阶函数：\nJavaScript 提供了许多内置的高阶函数来处理数组，这些函数使得数组操作更加简洁和易读。以下是一些常见的内置高阶函数：\n\nforEach：对数组的每个元素执行一次提供的函数。\n12const numbers = [1, 2, 3];numbers.forEach((num) =&gt; console.log(num * 2)); // 输出: 2, 4, 6\n\nmap：创建一个新数组，其元素是通过调用提供的函数处理原数组的每个元素。\n12const doubled = numbers.map((num) =&gt; num * 2);console.log(doubled); // 输出: [2, 4, 6]\n\nfilter：创建一个新数组，其元素是通过提供的函数测试的原数组的所有元素。\n12const evens = numbers.filter((num) =&gt; num % 2 === 0);console.log(evens); // 输出: [2]\n\nreduce：对数组的每个元素执行一个函数，将其结果汇总为单个值。\n12const sum = numbers.reduce((acc, num) =&gt; acc + num, 0);console.log(sum); // 输出: 6\n\nfind：返回数组中满足提供的测试函数的第一个元素。\n12const firstEven = numbers.find((num) =&gt; num % 2 === 0);console.log(firstEven); // 输出: 2\n\nfindIndex：返回数组中满足提供的测试函数的第一个元素的索引。\n12const firstEvenIndex = numbers.findIndex((num) =&gt; num % 2 === 0);console.log(firstEvenIndex); // 输出: 1\n\nsome：测试数组中是否至少有一个元素满足提供的测试函数。\n12const hasEven = numbers.some((num) =&gt; num % 2 === 0);console.log(hasEven); // 输出: true\n\nevery：测试数组中的所有元素是否都满足提供的测试函数。\n12const allPositive = numbers.every((num) =&gt; num &gt; 0);console.log(allPositive); // 输出: true\n\n这些高阶函数的参数是一个返回值为 Boolean 类型的回调函数，将筛选条件作为函数返回值的依据。\n自定义高阶函数：\n高阶函数不仅限于内置的数组方法，开发者也可以自定义高阶函数。以下是一个简单的自定义高阶函数示例：\n1234567891011function repeat(fn, times) {  return function (...args) {    for (let i = 0; i &lt; times; i++) {      fn(...args);    }  };}const sayHello = (name) =&gt; console.log(`Hello, ${name}!`);const repeatHello = repeat(sayHello, 3);repeatHello(\"Alice\"); // 输出: Hello, Alice! (3次)// 解释：repeat函数接受一个函数fn和一个次数times，返回一个新函数，该新函数会调用fn指定的次数。\n\n三、闭包闭包的定义与原理闭包的定义：\n\n1234567891011// 闭包示例function foo() {  var name = \"foo\";  function bar() {    console.log(name);  }  return bar; // 需要返回内部函数}var fn = foo();fn(); // 输出: foo\n\n闭包(Closure) 是指一个函数可以访问其外部作用域中的变量，即使在外部函数已经执行完毕后，内部函数仍然可以访问这些变量。也就是说最内层函数的父级作用域在执行后依然存在而没有被销毁。\n闭包的原理：\n这是因为内层函数在创建时会保存对其外部作用域的引用，而根据 JS 中的 GC 机制，只要引用存在，外部作用域就不会被销毁，因此外部作用域中的变量值也可以被“记住”。\n闭包的访问过程：\n闭包的执行过程：\n需要说明的是，若代码改为：\n1234567891011function foo() {  var name = \"foo\";  function bar() {    console.log(name);  }  return bar; // 返回内部函数}var fn1 = foo(); // 调用foo，返回bar函数fn1(); // 输出: foovar fn2 = foo(); // 再次调用foo，返回新的bar函数fn2(); // 输出: foo\n\n此时fn1 和 fn2 都是闭包，但它们各自保存了不同的外部作用域。每次调用 foo() 都会创建一个新的作用域，因此 fn1 和 fn2 分别引用了不同的 name 变量。\n闭包与内存泄漏闭包虽然非常有用，但如果不正确使用，可能会导致内存泄漏。内存泄漏是指不再需要的对象仍然被引用，从而无法被垃圾回收机制回收。\n\n使用闭包时需要注意以下性能问题：\n\n内存占用：闭包会保持对外部变量的引用，可能导致内存无法及时回收。\n避免在循环中大量创建闭包：可能导致性能问题和内存泄漏。\n及时清理不需要的闭包引用：在适当的时候将闭包变量设为 null，帮助垃圾回收。\n\n1234567891011121314// 内存泄漏示例function createHandler() {  const largeData = new Array(1000000).fill('data');    return function() {    // 即使不使用 largeData，它也会被保持在内存中    console.log('Handler called');  };}// 正确的做法：在不需要时清理引用let handler = createHandler();// ... 使用 handlerhandler = null; // 清理引用，帮助垃圾回收\n\n补充：存在闭包时AO对象的属性销毁理论上AO对象的属性与AO对象的生命周期相同，即当AO对象存在时，其全部属性都存在，当AO对象销毁时，其属性也会被销毁。\n但是实际上V8引擎在执行时会对AO对象的属性进行优化处理，当函数执行完毕后，AO对象的属性会被销毁，除非存在闭包引用了这些属性。\n12345678910111213141516// 验证function foo() {    var name = \"foo\";    var age = 18;    function bar() {        debugger; // 在这里可以观察到只有 name 在闭包中被保留        console.log(name); // 只引用了 name    }    return bar;}var fn = foo();fn(); // 输出: foo// 通过浏览器调试工具可以观察到：age 变量被 V8 优化掉了，因为闭包中没有引用它\n\n闭包的用途闭包在 JavaScript 中有许多用途，以下是一些常见的应用场景：\n\n数据封装和私有变量：闭包可以创建私有变量，这些变量只能通过特定的函数访问，从而实现数据封装。\n1234567891011121314151617181920function createCounter() {  let count = 0; // 私有变量  return {    increment: function () {      count++;      return count;    },    decrement: function () {      count--;      return count;    },    getCount: function () {      return count;    },  };}const counter = createCounter();console.log(counter.increment()); // 输出: 1console.log(counter.increment()); // 输出: 2console.log(counter.getCount()); // 输出: 2\n\n函数工厂：闭包可以用于创建函数工厂，根据不同的参数生成不同的函数。\n123456789function createMultiplier(factor) {  return function (x) {    return x * factor;  };}const double = createMultiplier(2);const triple = createMultiplier(3);console.log(double(5)); // 输出: 10console.log(triple(5)); // 输出: 15\n\n事件处理：闭包常用于事件处理函数中，可以访问外部变量。\n123456789function setupButton(buttonId) {  const button = document.getElementById(buttonId);  let clickCount = 0; // 私有变量  button.addEventListener(\"click\", function () {    clickCount++;    console.log(`Button clicked ${clickCount} times`);  });}setupButton(\"myButton\");\n\n延迟执行：闭包可以用于创建延迟执行的函数。\n1234567function delayedGreeting(name) {  return function () {    console.log(`Hello, ${name}!`);  };}const greetAlice = delayedGreeting(\"Alice\");setTimeout(greetAlice, 1000); // 1秒后输出: Hello, Alice!\n\n模块化编程：闭包可以用于创建模块，封装相关的功能和数据。\n1234567891011121314const Module = (function () {  let privateVar = 0; // 私有变量  return {    increment: function () {      privateVar++;      console.log(`Private variable: ${privateVar}`);    },    getPrivateVar: function () {      return privateVar;    },  };})();Module.increment(); // 输出: Private variable: 1console.log(Module.getPrivateVar()); // 输出: 1\n\n防抖和节流：在实际开发中，闭包常用于实现防抖和节流函数，优化性能。\n12345678910111213141516171819202122232425262728// 防抖函数（使用闭包保存定时器）function debounce(func, delay) {  let timeoutId;  return function(...args) {    clearTimeout(timeoutId);    timeoutId = setTimeout(() =&gt; func.apply(this, args), delay);  };}// 节流函数function throttle(func, delay) {  let lastTime = 0;  return function(...args) {    const now = Date.now();    if (now - lastTime &gt;= delay) {      func.apply(this, args);      lastTime = now;    }  };}// 使用示例const searchInput = document.getElementById('search');const debouncedSearch = debounce(function(event) {  console.log('搜索:', event.target.value);}, 300);searchInput.addEventListener('input', debouncedSearch);\n\n解决循环中的异步问题：闭包可以解决在循环中使用异步操作时的变量引用问题。\n12345678910111213141516171819202122// 问题代码for (var i = 0; i &lt; 5; i++) {  setTimeout(function() {    console.log(i); // 输出 5 个 5  }, 1000);}// 使用闭包解决for (var i = 0; i &lt; 5; i++) {  (function(j) {    setTimeout(function() {      console.log(j); // 输出 0, 1, 2, 3, 4    }, 1000);  })(i);}// 或使用 let（块级作用域）for (let i = 0; i &lt; 5; i++) {  setTimeout(function() {    console.log(i); // 输出 0, 1, 2, 3, 4  }, 1000);}\n\n函数柯里化：闭包是实现柯里化的重要手段。\n12345678910111213141516171819function curry(fn) {  return function curried(...args) {    if (args.length &gt;= fn.length) {      return fn.apply(this, args);    } else {      return function(...args2) {        return curried.apply(this, args.concat(args2));      }    }  };}function add(a, b, c) {  return a + b + c;}const curriedAdd = curry(add);console.log(curriedAdd(1)(2)(3)); // 输出: 6console.log(curriedAdd(1, 2)(3)); // 输出: 6\n\n总结高阶函数和闭包是 JavaScript 中非常重要的概念。高阶函数使得函数可以作为参数传递或返回，从而实现更灵活的编程模式,它源自 JS 中“函数是第一公民”的规则，也是闭包的实现基础。\n闭包则允许函数访问其外部作用域中的变量，即使外部函数已经执行完毕。使用闭包时也要注意避免内存泄漏问题，同时掌握存在闭包时的AO销毁机制。这些特性使得 JavaScript 在处理异步操作、事件处理和数据封装等方面非常强大。\n参考内容：\n\ncoderwhy 最强 JavaScript 高级教程 16-22 集\n\n","slug":"js-premier-2-higher-order-functions-and-closures","date":"2025-07-21T14:38:54.000Z","categories_index":"工作","tags_index":"前端,技术,JavaScript,笔记,进阶,函数,闭包","author_index":"Proselyte"},{"id":"0ef5e478d063e387bdfd27538e830494","title":"CSS水平居中样式的8种实现方式","content":"CSS 水平居中样式的8种实现方式假设需要设置水平居中样式的对象是 item ，其父元素为 container\n1. text-align: center行内元素水平居中(在父元素上设定)只对行内元素(inline、inline-block)有效\n123.container {    text-align: center;}\n\n2. margin: 0 auto块级元素水平居中需要指定宽度，只对块级元素有效\n1234.item {    width: 200px;    margin: 0 auto;}\n\n3. flex + justify-contentFlexbox 水平居中在 flex 容器上设置，适用于所有子元素\n1234.container {    display: flex;    justify-content: center;}\n\n4. flex + margin autoFlexbox 中单个项目水平居中在 flex 项目上设置，配合 display: flex 使用\n123456.container {    display: flex;}.item {    margin: 0 auto;}\n\n5. grid + justify-itemsGrid 水平居中所有项目\n1234.container {    display: grid;    justify-items: center;}\n\n6. grid + justify-selfGrid 水平居中单个项目\n123456.container {    display: grid;}.item {    justify-self: center;}\n\n7. absolute + transform绝对定位水平居中需要设置父元素为相对定位，即 position: relative\n12345.container {    position: absolute;    left: 50%;    transform: translateX(-50%);}\n\n8. absolute + 负 margin绝对定位水平居中(已知宽度)需要知道元素确切宽度\n123456.container {    position: absolute;    left: 50%;    width: 200px; /* 确定宽度 */    margin-left: -100px; /* 宽度的一半 */}\n","slug":"css-horizontal-center-in-eight-ways","date":"2025-07-17T10:31:03.000Z","categories_index":"工作","tags_index":"CSS,前端,技术,样式,水平居中,总结","author_index":"Proselyte"},{"id":"194d5c5216aeb653976ea78ea0fb0315","title":"JS高级-1-执行机制与作用域","content":"JS高级-1-执行机制与作用域一、浏览器运行与 V8 引擎1. JS 在浏览器中的运行原理\n流程：域名 -&gt; DNS 解析 -&gt; IP 地址(服务器地址) -&gt; 返回 index.html -&gt; 遇见标签下载对应的文件(CSS/JS) -&gt; 执行 JS 代码\n2. 浏览器内核与渲染浏览器内核：\n\n浏览器渲染：\n\n3. JS 引擎(V8 引擎)认识 JS 引擎：\n\n浏览器内核和 JS 引擎的关系：\n\nV8 引擎的原理：\n\nV8 引擎的架构：\n\nV8 引擎的解析图(官方)：\n\nV8 执行的细节：\n\n二、代码执行与作用域提升1. JS 代码的执行ECStack 、GO、EC、VO、AO浏览器会在计算机内存中分配一块内存，专门用来供代码执行的栈内存，称作执行环境栈 (ECStack) 同时会创建一个 全局对象(GO)，将内置的属性方法( isNaN、setInterval、setTimeout… )存放到一块单独的堆内存空间，并且使用 window 指向全局对象。\n在执行代码前，还需要创建一个全局执行上下文( EC(G) ), 创建完成后，进入到栈内存中去执行(进栈)；在当前全局执行上下文中，因为会创建很多变量并且赋值，所以会创建一个变量对象 VO(Varibale Object) 来进行保存，在函数私有上下文中的变量对象叫做 活动对象 AO(Activation Object) （ps: 每个执行上下文都有一个单独的变量对象）。\n总结一下：\n\n执行环境栈(ECStack)：专门用来供代码执行的 栈内存\n全局对象(GO)：存放内置的属性方法，window 指向\n全局执行上下文( EC(G) )：页面加载后进栈、销毁后出栈\n变量对象VO(Variable Object)： 存放当前执行上下文中创建的变量和值\n活动对象AO(Activation Object)： 函数私有上下文中的变量对象\n\n\n全局代码执行当一切准备就绪，就开始从上到下执行代码 (ps: 执行前还会涉及变量提升的问题，这里不进行展开)\n1var x = [12, 23];\n\njs 在解析这段代码时，会按照以下 3 个步骤\n\n先创建一个值 [12, 23]\n再创建一个变量 x\n最后将变量与值进行关联\n\n当创建的值是引用类型时，会在堆内存中开辟新的内存空间用了保存值，创建完成后，会将堆内存地址(通常是 16 进制 )保存到栈内存中； 如果创建的值是基本类型时，会直接保存到栈内存中\n\n在函数创建好后，继续向下执行\n1fn(x);\n\n通过上面的动图了解到，fn 和 x 都指向堆内存地址，所以，fn(x) 相当于 AAAFFF000(AAAFFF111) , 在执行函数体代码之前，我们需要知道的是：\n\n每次函数执行，都会创建一个函数私有执行上下文，创建完之后，需要进入到栈内存中去执行，此时，执行栈中的全局执行上下文就会被压入到栈底(压栈)\n同时，需要创建一个活动对象 AO 存放当前函数执行上下文中创建的变量和值等\n\n\n在完成函数执行上下文入栈后，接下来会做以下几件事\n\n初始化作用域链 scopeChain: 作用域链通常标记为 &lt;当前执行上下文, 函数创建时的作用域&gt; ，而作用域链是为了函数执行过程中，当活动对象中不存在某个变量时，会沿着作用域链向上找到\n初始化 this 指向: 本例子中，this 等于 window\n初始化实参集合 arguments\n形参赋值 y = x = AAAFFF111\n执行函数体 紧接着就是执行函数体内容，在执行完成后，当前函数的执行上下文就会出栈，退出执行栈，而被压入栈底的全局执行上下文又被推到了栈顶，此时会继续执行全局上下文中的代码\n\n\n至此，代码执行结束，最终输出的 x 是 [100, 23]。\n三、函数执行与作用域链函数执行时，除了会创建函数私有执行上下文外，还会创建一个作用域链，作用域链是为了在函数执行过程中，能够找到变量的值。\n作用域链的创建过程如下：\n\n创建函数私有执行上下文时，首先会创建一个作用域链 scopeChain\n作用域链通常标记为 &lt;当前执行上下文, 函数创建时的作用域&gt;\n当函数执行时，作用域链会沿着作用域链向上找到变量的值\n如果在当前执行上下文中找不到变量，则会沿着作用域链向上查找，直到找到全局执行上下文\n如果全局执行上下文中也找不到变量，则会抛出错误\n\n注意：作用域链在编译时创建，而与之后的调用位置无关，即便后来函数嵌套调用，其父级作用域仍为初始状态而不一定是外层函数。\n变量提升：指在函数执行前，变量会被提升到函数的顶部，但不会提升赋值操作。\n1234567// 变量提升示例function fn() {  console.log(x); // undefined  var x = 10; // 变量提升  console.log(x); // 10}fn();\n\n其本质为编译时创建的变量对象 VO 或 AO 中的变量添加了该属性，但还未执行赋值操作，因此其值为 undefined，但是存在该属性。\n四、相关面试题12345678910// 第一题var n = 100;function foo() {  n = 200;}foo();console.log(n); // 200/* 解释：函数foo中不存在变量n 因此执行时，n被提升到全局作用域中，找到，赋值200 */\n\n12345678910111213// 第二题function foo() {  console.log(n); // undefined  var n = 200;  console.log(n); // 200}var n = 100;foo();/* 解释：函数foo中声明了变量n，AO中n初始为undefined 因此执行到第一次打印时结构为undefined 接着执行n = 200赋值，最后输出200 此题中没有进行变量提升 */\n\n1234567891011121314151617181920// 第三题var n = 100;function foo1() {  console.log(n); // 100}function foo2() {  var n = 200;  console.log(n); // 200  foo1();}foo2();console.log(n); // 100/* 解释：全局作用域中的n被声明后在执行时赋值为100 函数foo1的父级作用域为全局作用域 而其中没有声明变量n，因此会沿着作用域链向上查找，找到全局作用域中的n，输出100 函数foo2中声明了变量n，先生成属性n为undefined的AO，再赋值为200，因此在foo2中输出200 foo2执行完后，最后打印的是全局作用域中的n，foo2未对其进行修改，输出100 */\n\n1234567891011121314// 第四题var a = 100;function foo() {  console.log(a); // undefined  return;  var a = 200;}foo();/* 解释：即使 return 后面的代码只在执行时运行，也能声明变量 因为函数foo中声明了变量a，AO中a初始为undefined 因此执行foo时，找到AO中的a，打印undefined */\n\n12345678910111213// 第五题function foo() {  var a = (b = 100);}foo();console.log(a); // undefinedconsole.log(b); // 100/* 解释：var a = b = 100 等价于 var a = 100 和 b = 100 这两条代码 因此函数foo中声明了变量a，AO中a初始为undefined 而b没有使用var、let、const声明，因此b被提升到全局作用域中 等价于在全局作用域中执行 var b = 100 因此在全局作用域中打印a时输出undefined，而打印b时输出100 */\n\n五、内存管理和 GC 垃圾回收算法认识内存管理：\n\nJS 的内存管理：\n\nJS 的垃圾回收：\n\n常用的 GC 算法：\n\n\n六、总结这是 JS 高级教程笔记整理的第一篇，此后这个系列将整理我有关 B 站 coderwhy 最强 JavaScript 高级教程的学习笔记，之后会补充 JS 面试题总结。笔记顺序大概参照视频课程的顺序，部分只是要求了解的内容可能不进行整理。\n本文整理了 JS 的执行机制、作用域链、内存管理和垃圾回收等内容，帮助理解 JS 的运行原理和内存管理方式。让我眼前一亮的是面试题考察的作用域链和变量提升的细节，这也是对 JS 运行机制的深入理解，不得不说 JS 还是非常值得钻研学习的。\n参考内容：\n\ncoderwhy 最强 JavaScript 高级教程 1-15 集\n通过动图了解 JS 中的 ECStack、EC、VO 和 AO\n\n","slug":"js-premier-1-executions-and-scoops","date":"2025-07-16T09:48:12.000Z","categories_index":"工作","tags_index":"前端,技术,JavaScript,面试,笔记,进阶,执行机制,作用域","author_index":"Proselyte"},{"id":"de29ad04e0c0a4f4e4f4656db4c38b06","title":"前端尺寸单位总结","content":"前端尺寸单位总结前端开发中对于标签元素的尺寸样式设置需要指定单位，如 px、em、rem、vh、rpx 等，本文将总结常用的前端尺寸单位及其使用场景。\n一、概述1. 所有单位及简述：\npx：像素 相对长度单位，相对于显示器屏幕分辨率(推荐使用)\nem：相对长度单位 基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。\nrem：相对单位 可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。\nvw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。\nvh：viewpoint height，视窗高度，1vh等于视窗高度的1%。 \nvmin：vw和vh中较小的那个。\nvmax：vw和vh中较大的那个。\n%：百分比\nin：寸\ncm：厘米\nmm：毫米\npt：point，大约1/72寸\npc：pica，大约6pt，1/6寸\n\n2. 分类：\n绝对单位：px、in、cm、mm、pt、pc\n相对单位：em、rem、%、vw、vh、vmin、vmax\n\n3. 换算工具推荐：VSCode 插件 px to rem\n二、典型单位1. pxpx (pixel)，表示像素，所谓像素就是呈现在我们显示器上的一个个小点，每个像素点都是大小等同的，所以像素为计量单位被分在了绝对长度单位中。有些人会把px认为是相对长度，原因在于在移动端中存在设备像素比，px实际显示的大小是不确定的。这里之所以认为px为绝对单位，在于px的大小和元素的其他属性无关。px是PC端前端开发最常用的尺寸单位，也最简单直观、最容易理解，但移动端开发不建议使用。\n\n\n\n\n\n\n\n\n\n物理像素：物理像素代表屏幕上有多少个像素点，如产品参数里“2340 x 1080 像素分辨率”指的就是设备像素，表示屏幕水平有1080个点，垂直有2340个点。设备独立像素（也称逻辑像素，device-independent pixels，dips）：表示屏幕展示物体的视觉尺寸是多少（进行缩放操作之后），逻辑像素相同就表示希望按钮在不同屏幕上看起来一样大，是日常生活说的“调节分辨率”中的“分辨率”。设备像素比（devicePixelRatio，dpr）： 指的是设备物理像素和逻辑像素的比例，PC端的设备像素比统一约等为1，移动端的设备像素比不确定且多样，这也是移动端开发不能使用px作为单位的根本原因。window.devicePixelRatio = 物理像素 / 设备独立像素 。CSS像素（pixel，px）：CSS像素是指CSS文件中使用的像素，取决于设备独立像素与缩放比例，CSS像素 = 缩放比的平方个设备独立像素。\n2. emem 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（1em = 16px）。为了简化 font-size 的换算，我们需要在css中的 body 选择器中声明font-size= 62.5%，这就使 em 值变为 16px*62.5% = 10px。这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的 px 数值除以 10，然后换上 em 作为单位就行了。\n特点：\n\nem 的值并不是固定的\nem 会继承父级元素的字体大小\nem 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸\n任意浏览器的默认字体高都是 16px\n\n3. remrem 参考物是相对于根元素，我们在使用时可以在根元素设置一个参考值即可，相对于em使用，减少很大运算工作量，例：html大小为10px，12rem就是120px。\n特点：\n\nrem单位可谓集相对大小和绝对大小的优点于一身\n和em不同的是rem总是相对于根元素，而不像em一样使用级联的方式来计算尺寸\n\n4. %% 是相对于父元素的大小设定的比率，若设置display: fixed;则相对于可视窗口。\n5. vw、vhvw 和 vh 都是相对于视窗的单位，1vw等于视窗宽度的1%，1vh等于视窗高度的1%，即可视窗口高100vh、宽100vw。\n6. rpxrpx是微信小程序独有的、解决屏幕自适应的尺寸单位。可以根据屏幕宽度进行自适应，不论大小屏幕，规定屏幕宽为 750rpx。通过 rpx 设置元素和字体的大小，小程序在不同尺寸的屏幕下，可以实现自动适配。\n三、总结本文总结了前端开发中常用的尺寸单位，并对px、em、rem、vw、vh等单位进行了详细说明。希望对您有所帮助，尤其是您在移动端开发遇到rpx、rem或相对单位时，可以参考本文进行单位转换和使用。\n参考文献：\n\ncss中px、em、rem、%、vw、vh、vm、rpx 这些单位的区别，最全面CSS单位了解，不懂的找我\n理解设备像素比devicePixelRatio\n物理像素、逻辑像素、CSS像素、PPI、设备像素比是什么\n\n","slug":"dimmensional-units-summary","date":"2025-07-11T12:28:26.000Z","categories_index":"工作","tags_index":"CSS,前端,技术,总结,设计,尺寸单位,合集,学习笔记","author_index":"Proselyte"},{"id":"b7c4cb340f06f266f05eab9dab265466","title":"Prompt优化学习笔记","content":"Prompt 优化学习笔记一、背景介绍在人工智能的语境下，Prompt特指用于触发和引导人工智能语言模型生成特定输出的文本或语句片段。\n在如今，与AI进行交互已经成为程序员工作生活中不可缺少的一部分。你是否有想过，为什么有些人用AI能快速完成工作，而有些人却总是产生不了令人满意的结果？\n这个问题的答案其实很简单：关键在于会不会使用提示词。 AI 提示词框架就像是帮助我们与AI更有效地沟通的「导航系统」，让它理解我们的需求并提供最佳回应。\nPrompt 本质上是一种注入式指令，它”指挥”AI 按照你预设的思路去思考问题、输出内容。熟练编写 Prompt，你就能充分利用 AI 的能力为你解决问题。\n二、提示词优化思路1. 详细询问，提供细节当与AI交流时，提供具体和详细的信息非常重要。这样做可以帮助AI更准确地理解你的需求和上下文，从而生成更相关和有用的回答。明确的信息可以包括具体的问题背景、相关领域的说明、你所期望的答案类型等。\n\n明确问题背景：提供足够的信息来描述你的问题背景。例如，如果你在问一个医学相关的问题，提供相关的症状或情境。\n具体描述需求：清楚地说明你需要什么类型的信息或帮助。例如，如果你需要建议，指明是寻求专业意见还是一般性建议。\n提供相关领域信息：如果问题涉及特定的知识领域，提供这一领域的相关信息，以便AI更精确地定位答案。\n避免模糊和广泛的问题：尽量避免提出过于广泛或模糊的问题，这样的问题往往导致AI无法提供具体和有用的回答。\n\n示例：\n\n不佳的提问：  \n改进后的提问：  \n\n2. 扮演角色要求AI采用一个特定的角色可以极大地增强交互体验和回答的相关性。当用户明确指定一个角色，如历史学家、医生、编程教师等，AI会尝试从该角色的视角回答问题，使对话更具针对性和深度。\n\n明确指定角色：在提问时，清楚地指出你希望ChatGPT扮演的角色。\n提供角色背景：如果可能，提供一些关于该角色的背景信息，例如专业知识领域、工作经验等。\n调整问题风格：根据选定的角色，调整你的提问风格，以便更好地适应这一角色的回答方式。\n\n示例：\n\n不佳的提问：  \n改进后的提问：  \n\n3. 明确输入分隔在与AI进行交互时，尤其是在处理包含多个不同部分或请求多项任务的复杂输入时，使用分隔符可以显著提高输入的清晰度和输出的质量。分隔符有助于明确界定输入中的不同部分，确保每个部分都能被准确识别和适当处理。\n\n选择合适的分隔符：根据输入的内容和格式，选择恰当的分隔符，如三引号(```)、XML标签、Markdown标题等。\n明确标注各部分：使用分隔符前后清楚地标注各个部分的开始和结束，尤其是在文本较长或复杂时。\n提供说明：在使用分隔符时，如果可能的话，给出简短的说明或注释，指明每个部分的内容或目的。\n\n示例：\n\n多部分问题：用户希望得到两个不同主题的解答，可以使用分隔符明确区分两个问题，简单的可以直接使用冒号分割：\n\n123解答下面的问题：问题1：请解释机器学习的基本概念。问题2：请列举健康饮食的三个基本原则。\n\n\n详细指令与背景信息：当用户需要提供详细的背景信息并请求具体的操作时，可以使用分隔符区分背景信息和具体请求：\n\n1234##背景：公司正计划扩展其市场到亚洲，特别是日本和韩国。##请求：基于此背景，提出一个市场进入策略的初步计划。\n\n\n使用XML标签处理多项内容：用户需要对两篇文章进行总结和比较，可以使用Markdown标签作为分隔符：\n\n123首先总结每篇文章的论点。然后指出哪篇文章提出了更好的论点,并解释为什么。``` 这里是第一篇文章的内容 `````` 这里是第二篇文章的内容 ```\n\n4. 提供示例在与AI的交互中，提供示例可以极大地增强清晰性和理解。当你提供一个具体的例子时，它有助于AI更准确地把握你的意图和上下文。这一点在解释复杂的概念、描述具体的情况或提出具体的问题时尤为重要。通常，给出适用于所有情况的通用指导比展示各种任务示例更高效。但在某些情况下，通过提供具体示例来说明可能更直观。比如，你想让模型学习某种特定的回应方式，这种方式可能难以用语言明确描述，这就是所谓的“少样本 (Few-shot)”提示方法。\n\n关联说明与实例：在提供说明时，紧跟一个相关的例子，这样可以帮助模型理解说明的上下文。\n明确示例的范围：确保你的例子足够具体，以展示你的询问或指令的具体应用。\n使用分隔符标明示例：如果可能，使用适当的分隔符（如引号、括号等）清晰地标识示例的开始和结束。\n\n示例:\n三、提示词框架1. ICIO适用场景：\n\n数据处理与转换：当用户需要 AI 处理特定的数据并按照特定格式输出时，如数据清洗、文本翻译或图像转换。\n\n内容创作：当用户希望 AI 为其创作特定风格或格式的内容，如撰写报告、创作诗歌或设计图像。\n\n技术任务：例如编码或算法设计，用户可以明确指定输入数据和期望的输出格式。\n\n教育与培训：当用户希望 AI 为其提供特定领域的知识或技能培训时，可以使用 ICIO 框架来明确学习内容和格式。\n\n\n定义：\n\n🤖 Instruction (任务)：你希望 AI 去做的任务，比如翻译或者写一段文字\n\n📋 Context (背景)：给 AI 更多的背景信息，引导模型做出更贴合需求的回复，比如你要他写的这段文字用在什么场景的、达到什么目的的\n\n📖 Input Data (输入数据)：告诉 AI 你这次你要他处理的数据。比如你要他翻译那么你每次要他翻译的句子就是「输入数据」\n\n📤 Output Indicator (输出格式)：告诉 AI 他输出的时候要用什么格式、风格、类型，如果你无所谓它输出时候的格式，也可以不写\n\n\n示例（翻译法文到英文用于商务报告）：\n1234567891011121314# Instruction 任务描述：请将以下的法文段落翻译成英文。重要性：翻译的准确性对于我们的商务报告至关重要。# Context 背景场景：这段法文将用于我们公司的年度商务报告。目的：报告将呈现给公司的股东和潜在投资者，所以翻译需要准确且专业。# Input Data 输入数据\"La croissance économique de la France a été stable au cours des dernières années, malgré les défis mondiaux.\"# Output Indicator 输出格式风格：正式和专业的商务英文风格。注意事项：请确保翻译内容无语法错误，并保持原文的意思。\n\n2. CRISPE适用场景：\n\n角色扮演与模拟：当用户希望 AI 模拟特定的角色进行互动，如医生、律师或教师，为其提供专业建议或解答。\n\n情境模拟：例如模拟商务谈判、心理咨询或角色扮演游戏，用户可以为 AI 提供详细的背景和角色描述。\n\n个性化互动：当用户希望 AI 具有特定的性格或风格进行互动，如幽默、正式或友好。\n\n多样化输出：当用户希望从 AI 那里获得多种不同的答案或建议，可以使用实验部分来请求多个示例。\n\n\n定义：\n\n😊 Capacity and Role (角色)：告诉 AI 你要他扮演的角色，比如老师、翻译官等等\n\n📜 Insight (背景)：告诉 AI 你让他扮演这个角色的背景，比如扮演老师是要教自己 10 岁的儿子等等\n\n📌 Statement (任务)：告诉 AI 你要他做什么任务\n\n🎨 Personality (格式)：告诉 AI 用什么风格、方式、格式来回答\n\n🧪 Experiment (实验)：请求 AI 为你回复多个示例（如果不需要，可无）\n\n\n案例（AI 作为数学老师帮助解决数学问题）：\n12345678910111213141516171819# Capacity and Role 角色描述：我希望你扮演一名经验丰富的小学数学老师。特点：具备耐心和鼓励性的教学风格，能够简单明了地解释数学概念。# Insight 背景学生信息：你将为我的10岁的儿子提供帮助，他目前正在学习小学四年级的数学。学习环境：他在家中进行在线学习，有时会遇到一些数学问题需要帮助。# Statement 任务描述：请帮助解答以下数学问题，并提供解题步骤。重要性：确保解答方法适合10岁儿童的理解能力。# Personality 格式风格：友好、鼓励性，使用简单易懂的语言。示例：可以使用实际生活中的例子来解释数学概念。# Experiment 实验描述：如果可能，请为每个问题提供两种不同的解题方法。目的：增强孩子的数学思维和解题能力。\n\n3. BROKE适用场景：\n\n项目管理与协作：当用户需要 AI 帮助管理项目、分配任务或协调团队合作时，BROKE 框架可以提供明确的背景、角色和目标，确保项目的成功执行。\n\n创意与设计：当用户希望 AI 为其提供创意建议、设计方案或艺术创作时，BROKE 框架可以确保 AI 的输出满足用户的关键要求，并根据反馈进行持续改进。\n\n研究与分析：当用户需要 AI 进行数据分析、市场研究或学术研究时，BROKE 框架可以为 AI 提供明确的研究背景和目标，确保研究结果的准确性和可靠性。\n\n\n定义：\n\n🌄 Background (背景)：说明背景，提供充足信息\n\n🎭 Role (角色)：你要 AI 扮演的角色是什么\n\n🎯 Objectives (目标/任务)：你要 AI 做的事情的一个描述\n\n🔑 Key Result (关键结果)：对于 AI 输出的回答，在风格、格式、内容等方面的要求\n\n🌟 Evolve (改进)：在 AI 给出回答以后，三种调整、改进方法\n\n\n案例（AI 作为项目经理帮助制定项目计划）：\n12345678910111213141516171819# Background项目描述：我们正在启动一个新的软件开发项目，目标是为中小企业提供一款高效的财务管理工具。团队组成：项目团队由5名开发人员、2名设计师、1名测试工程师和1名产品经理组成。# Role描述：我希望你扮演一名经验丰富的项目经理。特点：具备出色的项目管理技能，能够确保项目按时完成并满足预定的质量标准。# Objectives描述：请帮助我们制定一个详细的项目计划，包括项目的各个阶段、关键里程碑、资源分配和风险管理。# Key Result输出格式：项目计划应以Gantt图的形式呈现，并包括每个任务的开始和结束日期、负责人和依赖关系。关键指标：确保项目计划考虑到所有潜在的风险，并为每个风险提供了相应的应对策略。# Evolve反馈机制：在项目计划制定完成后，请提供一个反馈机制，以便团队成员可以提出他们的建议和改进意见。迭代：根据团队的反馈和项目进展，每两周对项目计划进行一次迭代和更新。持续监控：提供一个机制，以便我们可以实时监控项目的进展和状态。\n\n4. RASCEF适用场景：\n\n专业咨询与建议：当用户需要 AI 为其提供专业的建议或策略，如营销策略、财务规划或法律咨询，RASCEF 框架可以确保 AI 提供的建议是基于明确的上下文和角色。\n\n任务执行与流程管理：当用户希望 AI 帮助其执行特定的任务或管理工作流程，如项目管理、事件策划或销售流程，RASCEF 框架可以为 AI 提供明确的执行步骤和格式。\n\n\n定义：\n\n🎭 Role (角色)：这就是 AI 需要扮演的人，他可以是电子邮件营销人员、项目经理、厨师或您能想到的任何其他角色\n\n🔍 Action (行动)：这是人工智能需要做的，例如编写项目执行计划\n\n📝 Script (步骤)：这些是 A 完成操作应遵循的步骤\n\n🌐 Content (上下文)：这是背景信息或情况\n\n🔍 Example (示例)：这些是说明这一点的特定实例，它们帮助人工智能理解语气和思维/写作风格\n\n📄 Format (格式)：这是 AI 应该呈现其答案的方式，它可以是段落、列表、对话或任何其他格式\n\n\n案例：\n12345678910111213141516171819202122232425# Role 角色描述：我希望你扮演一名经验丰富的电子邮件营销人员。特点：具备出色的市场分析能力，了解当前的电子邮件营销趋势和最佳实践。# Action 行动任务：请为我们制定一个电子邮件营销策略，包括目标受众、内容策划和发送频率。# Script 步骤1.分析目标受众的特点和需求。2.设计电子邮件的内容和格式。3.制定发送计划和频率。4.设计跟踪和分析反馈的机制。# Content 上下文公司背景：我们是一家新兴的健康食品品牌，目标受众为20-40岁的健康生活爱好者。营销目标：提高品牌知名度，增加网站流量和促进产品销售。# Example 示例内容建议：可以设计一系列关于健康饮食的小贴士，每周发送一次。风格：友好、鼓励性，使用简单易懂的语言。# Format 格式电子邮件模板：使用清晰的标题、引人入胜的图片和简洁的文本内容。响应式设计：确保电子邮件在各种设备上都能正常显示。希望这样的格式和内容满足您的需求，如有其他修改或补充，请告诉我。\n\n5. 其他框架简述\nAPE 框架\nACTION:行动 定义要完成的工作或活动\nPURPOSE:目的 讨论意图或目标\nEXPECTATION:期望 陈述预期的结果\n\n\nCOAST 框架\nCONTEXT：上下文背景 为对话设定舞台\nOBJECTIVE：目的 描述目标\nACTION ：行动 解释所需行动\nSCENARIO：方案 描述场景\nTASK：任务 描述任务\n\n\nTAG 框架\nTASK：任务 描述任务\nACTION ：行动 解释所需行动\nGOAL：目标 解释最终目标\n\n\nRISE 框架\nROLE:角色 指定ChatGPT的角色\nINPUT:输入 描述信息或资源\nSTEPS：步骤 询问详细的步骤\nEXPECTATION 期望 描述所需的结果\n\n\nTRACE 框架\nTASK：任务 定义特定任务\nREQUEST：请求 描述要求\nACTION：行动 说明需要的操作\nCONTEXT：上下文 提供上下文信息或情况\nEXAMPLE：示例 举例子说明你想要达成的效果\n\n\nERA 框架\nEXPECTATION：期望 描述所需的结果\nROLE：角色 指定角色\nACTION：行动 指定需要采取哪些操作\n\n\nCARE 框架\nCONTEXT:上下文 提供上下文信息或情况\nACTION：行动 说明需要的操作\nRESULT：结果 描述所需的结果\nEXAMPLE：示例 举例子说明你想要达成的效果\n\n\nROSES 框架\nROLE：角色 指定角色\nOBJECTIVE：目的 陈述目标\nSCENARIO：方案 描述情况\nEXPECTED SOLUTION：解决方案 定义所需的结果\nSTEPS：步骤 要求达到目标所需的步骤\n\n\nPATFU 框架\nPROBLEM：问题 清晰的表达需要解决的问题\nAERA：领域 问题所在领域或需扮演的角色\nTASK：任务 解决这个问题需要执行的具体任务\nFORMAT：格式 详细定义输出的格式和限制条件\nUPDATE：迭代 记录提示词版本并根据输出结果对提示词进行迭代\n\n\n\n6. 提示词框架总结框架中常用的方面有：\n\n角色：赋予AI的身份\n任务：整体说明需要完成哪些任务\n问题：当前存在的不足\n背景：相关背景信息\n格式：结果格式要求\n期望：结果期望\n行动：说明需要进行的操作\n目的：实现效果，较笼统\n方案：给出详细的实现步骤或技术栈\n示例：符合格式要求的具体例子，输入输出均可\n实验：对于回复的预测、猜想，提供思路\n\n可灵活补充选择，结合情境和需求使用。\n四、总结本文从背景、理论与实践三个方面介绍了提示词相关知识，通过学习笔者也认识到框架不是死记硬背而是要以目的为导向，许多框架之间也是高度相似或者换了个说法，本文出于尽可能全面收集整理的目的并未进行合并或删减，关键仍是有比较清晰的思路和目的，从而选择合适的引导方面。\n参考文献：\n\n你要牢记的四个常用AI提示词框架：ICIO、CRISPE、BROKE、RASCEF，有助于获取更加稳定和高质量的内容\n一文汇总市面上所有prompts提示词框架！\n一文汇总Prompt提示工程的相关策略技巧\nAI 入门：AI 提示词如何入门？这篇就够了！（含提示词）\n\n","slug":"prompt-learning-notes","date":"2025-07-11T10:54:36.000Z","categories_index":"工作","tags_index":"技术,学习笔记,Prompt,AI,优化","author_index":"Proselyte"},{"id":"cfd65de29f7f6b5bac382ae133f350db","title":"Three.js 学习笔记","content":"Three.js 学习笔记一、背景介绍二、学习笔记1、Three.js 官方文档学习笔记2、Three.js in React 学习笔记3、Three.js 项目实战三、总结","slug":"threejs-learning-notes","date":"2025-07-11T10:49:30.000Z","categories_index":"工作","tags_index":"前端,技术,学习笔记,Three.js,Web","author_index":"Proselyte"},{"id":"dbfa94e497ba7ab286c1c4d2789db0e2","title":"Tabbar中的UI/UX设计","content":"Tabbar中的UI/UX设计Tabbar对于移动端的前端开发是不可避免的，本文将对于其UI/UX设计进行介绍。\nTabbar是什么？Tabbar是指移动端应用中常见的底部导航栏组件，用于切换不同功能页面。\nTabbar的设计原则与理想效果\n\n\n\n\n\n\n\n\nTabbar的设计原则大致可用几个词总结：简洁、易用、易于理解、风格统一和谐……\n\n设计良好的Tabbar可以方便用户切换功能模块、提升操作效率与用户体验。\n可以使应用风格统一美观。\n国外部分设计加入动效，增强互动性，但可能增加性能开销，国内使用较少。\n\n总之，设计可考虑两种思路，一种是简洁合理，让用户使用自然、感觉不到突兀，常用于日常成型的APP设计；另一种则是追求新意，增加动效、视觉效果，常用于个人展示类APP或创意类APP设计。\nTabbar的具体设计1. 组成元素Tabbar的主体当然是切换按钮，其样式（包括选中与未选中状态）、位置、数量、排列方式等都需要设计。同时，空白部分、分界线、文字说明等元素也需要考虑。\n2. 颜色需要考虑与整体风格的明暗、主题色保持统一。\n\n建议背景色采用主题色或整体设计应用较多的偏深的颜色，起到托底的效果，以免有“头重脚轻”的感觉。（补充：顶部的Navbar也不建议应用太多浅色，可以考虑图片或者较浅的主题色）\n图标颜色可考虑黑或白（与明暗主体相反）。\n\n3. 图标图标的选择要兼具美观与可读性。\n\n图标数目应控制在2~5个（3~4个为最佳），避免过多或过少，以免造成混乱。\n图标的大小应适中，避免过大或过小，以免影响美观。\n图标风格需一致，可选单色/多色、线条/实心等，但切忌混搭，若非专业设计师建议选择同一素材库中的图标素材，建议不要使用3D或者过于复杂的多色图标（技巧：选中的图标可与其他图标风格不同以区分）。\n\n4. 文字图标的文字说明是可选的但通常加上以帮助对于图标的理解。\n\n文字的大小应合适，避免过大或过小，以免影响美观。\n文字颜色一般与图标一致。\n\n5. 技巧\nActive 与 Inactive 状态的应进行区分\n选择简洁、熟悉的图标\n文字简短、长度恰当\n保持整体风格干净简洁\n选择一种图标风格\n使用通知提醒的badges\n尝试有创造力的布局设计，如中间的“添加”图标变色、上移\n将 Tabbar 与主内容分开\n使用合适的背景色\n添加流畅的微互动\n\n6. 误区\n避免使用多种颜色\n避免将不合理的颜色对照用于区分状态\n\n总结这是我写的第一篇关于UI/UX设计的文章，素材来自油管:Top UI/UX Design Tips - How to Design a Great Bottom Mobile Navigation Bar。关于设计艺术与美感的事物，确实不如实际的代码逻辑容易表述，我将继续提升自己的设计水平和表达能力，同时后续将更新图片以供参考。希望您在读完之后能有所收获！\n\n","slug":"ui-ux-design-in-tabbar","date":"2025-05-21T06:16:25.000Z","categories_index":"工作","tags_index":"教程,前端,设计,UI/UX,移动端","author_index":"Proselyte"},{"id":"7b8bf44f2423c96f4d6c41f38573648a","title":"关于'名字'","content":"关于’名字’名字，一张名片罢了。\n\n\n\n\n\n\n\n\n\n“从父母取的名字里可以看出一个人的背景希冀，从自己取的别名中可以看出一个人的心理性格。”\n这是一种比较普遍认可的心理学观点。\n但我想提出两种全新的角度学习交流：\n1. 感觉以我个人为例，我对“一帆”并不感冒，因为名字本意上的“一帆风顺”从不是我所追求的，我喜欢 “乘风破浪” 的态度，而不是甘于平淡。\n但是 “帆” 这个字对我的“诱惑”太大了：一声，再加上这个字本身的意境，让我想到 “朝平两岸阔，风正一帆悬” 这句诗，那种自由而积极的感觉扑面而来，仿佛此刻正面对朝阳翱翔。\n因此，我在一切能取中文昵称的地方，基本上都会以 “帆” 作为昵称，而不再加其他过于繁复冗余的修饰。\n同样因此，当很多老师第一次点名叫出“凡”的读音时我都有些不快，这与某个名字相近的明星无关，只是他/她破坏了这份意境，所以我一定要找机会告诉他应该读一声。（我至今仍比较怀疑读错的原因，难道不知道“一帆风顺”这个成语？？？真是怪事，大无语）\n所以我认为，抛开名字本身“福禄寿”之类的祝福，单纯去体悟那种语言的感觉或者意境是一件十分有趣的事情，说不定像我这样也能带给你积极的人生态度与心理暗示。这也是汉语最美妙的地方之一，凝练，深刻，这大概就是背后的文化吧。\n2. 目的此处说的目的，专用于自己取的名字，而非你生来就有的姓名。它可以是你起的QQ、微信、游戏等等各个账号的昵称，可以是你参加比赛等活动是起的项目名，也可以是对于已有产品名字的研究。\n这些名字的共同点在于它们都是需要向外界展示的，因此也就不可避免地带有目的性。\n我有一段比较有趣的经历，那就是在B站作为Up主曾尝试过发一些视频。题材尝试过风景、小提琴、足球、游戏，最后选择了发炉石传说的视频。一方面因为我自己确实比较擅长炉石，另一方面也是因为我可以做到尽可能多的去更新（点一下录屏就有素材了）。\n在发布我自己的视频的同时，我也认真研究过其他Up主，无论是同为炉石圈里的还是其他游戏领域的，我仔细观摩学习他们的昵称、视频封面、视频名，总结一个认真的（指不是搞抽象或者蹭流量的低智视频）爆火视频的成功经验。\n一段时间后，我自己做的炉石视频也用上了这些方法，做的视频也有一些小成就，赚了一点小钱。总结一下我的工作，其中做的最好的大概是选一个合适的视频题目吧，贴合内容、吸引关注还不博眼球（不违良心），能给自己打8分以上。至于做视频封面，我的图像处理功底比较差，只能给自己打5~7分（也就是大概及格）；至于我的昵称，我只能给自己打4分，因为我比较固执地选择的这个英文版昵称 “Proselyte” 确实既不好读也不好记，词本身还非常生僻，几乎踩了选昵称的所有坑，但是，我却决定坚持这份固执，即便是早知道这些问题。\n所以，为什么我不改名字呢？一方面，这是我对于做视频初衷的理解，即这绝非我的工作或者应该全心投入的事情，它只是我了解社会、了解互联网所做的一次试验，我确实不大在意会不会有更多人关注我，至少我的视频的播放量还不错，这已经足以让我满足了，我不必绞尽脑汁想一个“好名字”；同时，就像我对“帆”的感觉一样，我也对“Proselyte”有一些自己的想法。\nProselyte，在词典中的意思是“变节者”或者“异教徒”，它的意思中与宗教方面的含义比较多，但和我一点关系都没有，也跟我其这个昵称的想法无关。本人无宗教信仰，坚决支持马克思主义。我会把它的中文义称作 “异教” ，这源自《命令与征服2》（红警2）的著名mod “心灵终结” 中玩家所扮演的尤里阵营的角色。在剧情中玩家将扮演他带领着厄普西隆的军队用智谋取得一次次取得扭转战局的胜利，并最终建立一个“全新的”“自由世界”。不得不说，诡计与心灵控制，这些红警2所赋予尤里阵营的特性还是相当迷人的。善于利用他人的弱点，又有勇于创造的野心，最终背弃了传统的政治理念，选择了新兴的“异教”，这种反叛与自由的精神也吸引我展开游戏之外的遐想。\n说回我自己，选择这个昵称，一方面肯定是因为那种反叛精神的酷，希望自己能开辟一番事业；同时也希望我自己不要一直安于循规蹈矩，而要能跳出条条框框的限制，敢于质疑，勇于突破，用更深的思考带来质变的创新。\n总结写到这里，我想分享的大概就是这样了。其实本来我只想解释一下我的两个昵称，但当指尖真正触碰到键盘的一刻，又有了新的想法，我就又把它们的解释揉进了这两个观点里。我希望我的昵称不只是一个简单的string，更是时时刻刻看到时激励我自己的生活态度，提醒自己所选择的道路、追求的理想。\n\n\n\n\n\n\n\n\n\n“一片树林里分出两条路——而我选择了人迹更少的一条，从此决定了我一生的道路。”——《未择之路》 罗伯特·弗罗斯特\n","slug":"about-name","date":"2025-03-21T15:22:02.000Z","categories_index":"生活","tags_index":"生活,关于,随笔,名字","author_index":"Proselyte"},{"id":"0ffaa1f7ae518731edb051d9250ce9ae","title":"学过React还能不会Zustand?","content":"学过 React 还能不会 Zustand ?意思是Zustand上手难度低、学会React就能用，简洁高效，尤其适合对于Redux的复杂有些恐惧的初学者。\n什么是状态管理？为了防止初学者对状态管理的概念理解不够深入，而以为只是 useState 或者 useReducer 这样的钩子函数，下面再阐释一下相关概念：\n\n状态管理：指的是应用中不同组件之间共享的状态，如用户输入、网络请求、应用数据等，广义上也可指对于应用中的变量、数据等状态等的管理。\n状态管理的作用：主要是为了解决组件之间共享状态的问题，让组件之间的数据共享更加简单、可控。\n状态管理库：上文提到的 useState 和 useReducer 只能实现单一文件内的状态管理，而无法实现跨文件共享状态。此时就需要使用状态管理库，如 Redux、MobX、Zustand 等，来实现跨文件共享状态或者全局状态管理。\n\n什么是 Zustand ？Zustand 是一个轻量级的状态管理库，它可以帮助我们管理 React 应用中的状态，让我们在React组件中轻松地共享状态。虽然其发展历史比较短，但已经成为 React 生态中最流行的状态管理库之一，广受欢迎，在GitHub上的仓库已有超过 50k 的 star⭐！\nZustand 的核心思想是使用类似钩子函数来管理状态，它可以让我们在函数组件中管理状态，而无需使用class组件。因此这也降低了学习成本，同时使Zustand的语法更加简洁明了。\n以下内容将对 Zustand 进行简单的上手指导，相信您在认真阅读后一定能轻松上手这款实用的状态管理库，但同时它的一些复杂的特性还需要您后续学习。本文档参考 Zustand 官方文档完成，欢迎您前往官网学习。\n如何上手Zustand？Zustand 的使用非常简单，我们只需要安装 Zustand 库，然后在 React 组件中引入 useStore 函数，并在函数组件中使用 useStore 来获取状态。\n1. 安装12345## NPMnpm install zustand## Yarnyarn add zustand\n\n2. 创建 Store您的 store 就像一个 Hook！你可以把任何东西放进去：原始值、对象、函数。set 函数会合并状态。\ncreate 是用来创建的方法，而 set 方法则用来更新状态。\n注意：您在初始化函数中定义的状态变量都应该具有初始值或者对应的函数，而不能为未定义状态。\n123456789// 示例import { create } from 'zustand'const useStore = create((set) =&gt; ({  bears: 0,  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),  removeAllBears: () =&gt; set({ bears: 0 }),  updateBears: (newBears) =&gt; set({ bears: newBears }),}))\n\n3. 绑定组件您可以在任何地方使用钩子，无需提供 Provider。选择您的状态，当状态改变时，使用该状态的组件将重新渲染。\n使用方法即在函数内对状态变量进行实例化，使用 useStore 钩子声明为 const xxx = useStore((state) =&gt; state.xxx)。之后即可在函数内使用状态变量或者调用对应的 store 中的方法来更新状态值。\n12345678910111213141516171819202122232425262728293031323334353637// 示例import { Button, Space } from 'antd'import { create } from 'zustand'const useStore = create((set) =&gt; ({  bears: 0,  increasePopulation: () =&gt; set((state) =&gt; ({ bears: state.bears + 1 })),  removeAllBears: () =&gt; set({ bears: 0 }),  updateBears: (newBears) =&gt; set({ bears: newBears }),}))function BearCounter() {  const bears = useStore((state) =&gt; state.bears)  return &lt;h1&gt;{bears} around here ...&lt;/h1&gt;}function Controls() {  const bears = useStore((state) =&gt; state.bears)  const increasePopulation = useStore((state) =&gt; state.increasePopulation)  const removeAllBears = useStore((state) =&gt; state.removeAllBears)  return (    &lt;Space size=\"large\"&gt;      &lt;Button type=\"primary\" onClick={increasePopulation}&gt;one up&lt;/Button&gt;      {bears &gt; 0 &amp;&amp; &lt;Button type=\"primary\" danger onClick={removeAllBears}&gt;clear&lt;/Button&gt;}    &lt;/Space&gt;  )}export default () =&gt; {  return (    &lt;&gt;      &lt;BearCounter /&gt;      &lt;Controls /&gt;    &lt;/&gt;  )}\n\n4. 多变量对象状态更新您可以在 store 中将一个对象进行状态管理，此时可能需要同时更新该对象中的若干属性，建议您在 set 方法中使用 ... 扩展运算符，可以便捷地进行状态更新。\n12// 示例set((state) =&gt; ({ ...state, count: state.count + 1 })) // 在这个例子中，前后状态中除了 `count` 这一个属性更新外，其余属性保持不变\n\n5. TypeScript 指南您必须在 create 方法后面加上类型声明，即 create&lt;T&gt;()(...)，而非 create(...)，其中 T 是状态类型以进行注释。\n总结Zustand 是一个非常适合初学者的状态管理库，它简洁的语法可以帮助我们以较低的学习成本在 React 中进行状态管理。以上介绍了 Zustand 的一些简单语法，希望能帮助您快速上手。复杂语法及详细语法请参考Zustand 官方文档。\n希望本文对您有所帮助，祝您学习与生活愉快！😘✨💖\n","slug":"zustand-tutorial","date":"2025-03-18T15:25:50.000Z","categories_index":"工作","tags_index":"教程,前端,React,Zustand,状态管理","author_index":"Proselyte"},{"id":"7ddf4c82aed267f815c6dc36ea759994","title":"关于'关于'","content":"关于’关于’由于我个人并不喜欢经常发朋友圈或者逢人便主动介绍我自己的一些想法与特点但我有的时候又很有分享欲，因此我决定开一个名为“关于”的栏目，在这里假装有位记者“恰好”采访了我“关于”我的某某事的问题，我再进行一下回答和解释。\n毕竟博客不是朋友圈，不会有人一直来看或者闲着刷，不过这样反倒挺好的，既能给我足够的安全感而且能满足我的分享欲。\n当然，您不会从中得到任何我的隐私信息的分享，我想分享的更多是一种从我的选择中体现的生活态度和思考或者分享一些我认为有趣的想法。\n后续这个分类将发布类似关于名字、关于足球、关于大连等一系列文章。如果能引起您的共鸣或者思考也欢迎交流；如果您希望了解我的某些事情也可以向我提出，我会考虑后决定是否写一篇相关的文章分享。\n这是关于此分类的介绍文章，也是第一篇文章，希望我能坚持更新下去，也希望我为数不多的读者能够喜欢。❤\n","slug":"about-about","date":"2025-03-14T15:25:31.000Z","categories_index":"关于","tags_index":"生活,关于,分享,随笔","author_index":"Proselyte"},{"id":"e02f7c90edc3d301451d23642501565c","title":"CSS进阶之多端适配与响应式布局","content":"CSS 进阶之多端适配与响应式布局一、是什么？\n多端适配（Cross-platform adaptation）：指的是网站能够兼容多种设备，包括 PC、手机、平板等。而造成“不适配”的原因重点在于不同设备/端的屏幕尺寸不同，若不进行适配，可能影响页面显示/布局，造成不好的用户体验甚至网站功能无法使用。\n\n响应式布局是一种通过使用 CSS 构建在不同的设备上都能正常显示的网页的设计方法。它能够使网页在不同的屏幕尺寸上都能有较好的显示效果，是解决多端适配的一种有效方法。\n\n\n二、解决多端适配思路1. 多端分别适配针对不同设备/端，分别制作不同的网页（不同端差距较大），然后通过前端监测屏幕宽度以匹配合适的网页路由进行加载。\n\n适用情境：不同端页面内容差距大、无法通过页面组件的比例缩放实现布局统一的项目。如淘宝等电商平台，手机端的商品列表与 PC 端的商品列表尺寸差距太大，需要分别制作。而对于一些类似的功能可考虑代码复用或适配响应式布局。\n优点：灵活性强，可以最大化发挥大屏的显示优势与小屏的操作便利性。\n缺点：维护成本高，不同端页面需要分别制作，开发成本高。\n\n使用 React 实现的代码示例：\n123456789101112131415161718192021222324252627282930313233343536373839404142// 多端分别适配核心代码示例import React, { useEffect, useState } from 'react';import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'; // 以 React Router 路由库做演示// 页面组件const Page1 = () =&gt; &lt;div&gt;页面1（小屏端）&lt;/div&gt;;const Page2 = () =&gt; &lt;div&gt;页面2（中屏端）&lt;/div&gt;;const Page3 = () =&gt; &lt;div&gt;页面3（大屏端）&lt;/div&gt;;// 获取当前屏幕尺寸类型function getScreenType() {  const width = window.innerWidth;  if (width &lt;= 768) return 1;        // 小屏  if (width &lt;= 1024) return 2;       // 中屏  return 3;                          // 大屏}const App = () =&gt; {  const [screenType, setScreenType] = useState(getScreenType());  useEffect(() =&gt; {    const handleResize = () =&gt; setScreenType(getScreenType());    window.addEventListener('resize', handleResize);    return () =&gt; window.removeEventListener('resize', handleResize);  }, []);  // 根据屏幕类型选择路由  return (    &lt;Router&gt;      &lt;Routes&gt;        {screenType === 1 &amp;&amp; &lt;Route path=\"*\" element={&lt;Page1 /&gt;} /&gt;}        {screenType === 2 &amp;&amp; &lt;Route path=\"*\" element={&lt;Page2 /&gt;} /&gt;}        {screenType === 3 &amp;&amp; &lt;Route path=\"*\" element={&lt;Page3 /&gt;} /&gt;}        {/* 可选：默认重定向 */}        &lt;Route path=\"*\" element={&lt;Navigate to=\"/\" /&gt;} /&gt;      &lt;/Routes&gt;    &lt;/Router&gt;  );};export default App;\n\n2. 响应式布局使用一套代码或进行代码大量复用，通过媒体查询和百分比宽度实现不同屏幕尺寸的网页设计布局。\n\n适用情景：页面内容、布局、组件等都能根据不同屏幕尺寸进行自适应调整，且页面内容、布局、组件等都能通过 CSS 代码实现。\n优点：代码量少，维护成本低，对于临界尺寸等特殊情况也能有较好的适配效果。\n缺点：较为不灵活，部分特殊细节无法完全通过调节比例实现，仍需重写代码；需进行较多尺寸计算，开发难度较大。\n\n三、响应式布局实现方法1. 媒体查询媒体查询是 CSS3 引入的新特性，它允许我们根据不同的设备和不同的屏幕尺寸来定义不同的样式。\n12345678910/* 媒体查询 */@media screen and (max-width: 768px) { /* 针对小屏幕的样式 */}@media screen and (min-width: 768px) and (max-width: 1024px) {  /* 针对中等屏幕的样式 */}@media screen and (min-width: 1024px) { /* 针对大屏幕的样式 */}\n\n2. 相对尺寸单位指使用 em、rem、vw、vh、% 等相对单位来设置元素的宽度、高度、字体大小等。\n相对单位使用及换算可参考本人博客文章：前端尺寸单位总结。\n3. 布局中采用比例如flex布局用百分比宽度实现响应式布局、或者grid布局用网格比例实现响应式布局。本质上仍使使用相对尺寸单位，即相对尺寸单位可与布局结合实际运用。\n1234567891011121314151617/* flex布局 */.container {  display: flex;  flex-wrap: wrap;}.item {  width: 100%;  height: 0;  padding-bottom: 56.25%; /* 16:9 */}/* -------------- *//* grid布局 */.container {  display: grid;  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));}\n\n四、总结响应式布局已经成为现代开发不可忽视的一方面，也是一个成熟的应用项目所必备的特性，而移动端设备的尺寸多样与设备像素比不确定造成了响应式布局的复杂性，是实现的难点。本文介绍了多端适配与响应式布局的概念及实现方法，希望能帮助读者入门相关概念，而具体运用还需要大量的实践和思考。最后补充一下：灵活利用CSS的calc()函数以及JavaScript的DOM操作等知识也是实现动态监视屏幕尺寸的技巧。\n","slug":"multi-device-and-responsive-layout","date":"2025-03-14T15:24:21.000Z","categories_index":"工作","tags_index":"CSS,教程,前端,响应式布局","author_index":"Proselyte"},{"id":"79a90e787e3c9f8206ec85badb1d113a","title":"CSS基础之flex与grid布局","content":"更新中……敬请期待……\n","slug":"css-flex-and-grid-layout","date":"2025-03-14T15:21:01.000Z","categories_index":"工作","tags_index":"CSS,flex,grid,教程,前端","author_index":"Proselyte"},{"id":"8346f930f0602a19ad33cbd2e008a718","title":"Angular提交规范详解","content":"Angular 提交规范详解一、是什么？Angular 提交规范是指由 Angular 官方团队制定的提交规范，旨在统一 Angular 项目的提交信息，方便项目维护者和贡献者更好地管理项目。它是 Git Commit 规范的一种，学习并遵循 Angular 提交规范，可以有助于我们更好地管理项目，提高项目的质量和效率。\n二、如何使用？Angular 提交规范出处请参阅官方仓库说明，以下是个人的理解说明：\n1. 提交格式每次提交，Commit message 都包括三个部分：Header、Body 和 Footer。其中，Header 是必需的，Body 和 Footer 可以省略。\n12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;\n\n2. HeaderHeader 部分包括三个字段：type、scope 和 subject。\n\ntype：用于说明 commit 的类别，只允许使用下面 7 个标识：\nfeat：新功能（feature）\nfix：修复 bug\ndocs：文档（documentation）\nstyle：格式（不影响代码运行的变动）\nrefactor：重构（即不是新增功能，也不是修改bug的代码变动）\ntest：增加测试\nchore：构建过程或辅助工具的变动\n\n\nscope：用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\nsubject：是 commit 目的的简短描述，不超过 50 个字符。\n\n3. BodyBody 部分是对本次 commit 的详细描述，可以分为多行。\n注意：- 使用第一人称现在时，比如使用change而不是changed或changes。- Body 部分需要进行详细描述，说明代码变动的动机，以及与以前行为的对比。\n下面是一个范例：\n12345More detailed explanatory text, if necessary.  Wrap it to about 72characters or so. - Bullet points are okay, too- Use a hanging indent\n\n4. FooterFooter 部分只用于两种情况：\n\n不兼容变动\n关闭 Issue\n\n如果有，Footer 部分以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动理由和迁移方法。\n12345BREAKING CHANGE: &lt;breaking change description&gt;  &lt;breaking change explanation&gt;Closes #&lt;issue number&gt;\n\n5. 其他\n回滚（Revert）\n如果当前 commit 用于回滚某个 commit，则必须以 revert: 开头，后面跟着被回滚的提交的 Header。\n正文中添加 This reverts commit &lt;hash&gt;.，其中 &lt;hash&gt; 是被回滚的提交的 SHA 标识符。\n\n\n参考（Reference）\n可以附加参考文献或链接。\n参考文献可以是任何格式，如 URL、文献标题、出版物名称等。\n参考文献应放在 Footer 部分，并以 References 开头。\n\n\n\n三、总结Angular 提交规范是 Git Commit 规范的一种，学习并遵循 Angular 提交规范，可以有助于我们更好地管理项目，提高项目的质量和效率。\n希望本文对您有所帮助，祝您学习与生活愉快！😘✨💖\n","slug":"angular-commitement-rules","date":"2025-03-13T02:21:07.000Z","categories_index":"工作","tags_index":"教程,技术,Git Commit,Angular,规范","author_index":"Proselyte"},{"id":"8c1022cabd91a37952212dad2c11d30e","title":"Git上手指北","content":"Git上手指北1. 什么是Git？Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git与常用的版本控制工具CVS、Subversion等不同，它采用了分布式版本库的方式，不必服务器端支持。\n2. 为什么要使用Git？\n版本控制：Git可以帮助你管理代码的历史记录，让你能清晰地看到每一次更新的内容。\n团队协作：Git可以让多人协作开发一个项目，每个人都可以提交更新，并拉取同步其他人的更新。\n代码分享：Git可以让你分享你的代码，让其他人可以看到你的成果，并帮助你发现Bug。\n代码备份：Git可以帮助你备份你的代码，避免意外丢失或者不可挽回的误操作。\n\nGit已成为目前最流行的版本控制工具，是开发者必备的技能。\n3. Git的安装Git的安装非常简单，只需要到Git官网下载安装包，然后根据提示一步步安装就可以了。\n4. Git的基本使用Git的基本使用包括配置、初始化、添加、提交、状态查看、日志查看、撤销、分支管理、合并等。下面我们来一一介绍。\n4.1 配置Git的配置有若干选项，其中最必要的是用户名和邮箱的设置（之后您的每一次提交将使用这些信息），请您打开命令行或Git Bash输入以下命令进行配置。\n12git config --global user.name \"your name\"git config --global user.email \"your email\"\n\n更多配置选项请参考Git官方文档。\n4.2 初始化Git的初始化包括在工作目录下创建一个新的Git仓库，或者克隆一个已有的仓库。\n1git init\n\n4.3 添加Git的添加包括将文件添加到暂存区以及将暂存区的文件提交到本地仓库。\n12git add file1 file2...git commit -m \"commit message\"\n\n4.4 状态查看Git的状态查看包括查看当前文件状态、查看暂存区状态、查看本地仓库状态。\n123git statusgit status -sgit status --short\n\n4.5 日志查看Git的日志查看包括查看提交历史、查看文件修改历史。\n123git loggit log --onelinegit log --graph\n\n4.6 撤销Git的撤销包括撤销工作区的修改、撤销暂存区的修改、撤销本地仓库的修改。\n123git checkout -- file1 file2...git reset HEAD file1 file2...git reset --hard HEAD^\n\n4.7 分支管理Git的分支管理包括创建分支、切换分支、合并分支、删除分支。\n1234git branch branch-namegit checkout branch-namegit merge branch-namegit branch -d branch-name\n\n4.8 合并Git的合并包括合并两个分支、合并指定分支到当前分支。\n12git merge branch-namegit rebase branch-name\n\n5. Git与GitHubGitHub是目前最大的Git代码托管平台，是Git的最大用户，也是Git最常见的应用场景。Git与GitHub的结合可以让你在线管理你的代码，并与他人分享你的成果。下面我们来介绍如何使用GitHub。\n5.1 注册GitHub账号首先，你需要注册一个GitHub账号。\n5.2 创建仓库登录GitHub后，点击右上角的“+”按钮，选择“New repository”创建仓库。\nPS. repository的英文意思是仓库。\n5.3 克隆仓库克隆仓库包括两种方式：\n\nHTTPS方式：复制仓库的HTTPS地址，使用命令git clone https://github.com/your-username/your-repository.git克隆仓库。\nSSH方式：生成SSH密钥，使用命令ssh-keygen -t rsa -C \"your-email\"生成SSH密钥，然后添加SSH密钥到GitHub，使用命令git clone git@github.com:your-username/your-repository.git克隆仓库。\n\n5.4 推送代码推送代码包括将本地仓库的修改推送到远程仓库，使用命令git push origin master推送代码。\n5.5 创建分支创建分支包括创建新分支、切换分支。\n12git branch new-branchgit checkout new-branch\n\n5.6 提交代码提交代码包括将本地仓库的修改提交到本地仓库，使用命令git commit -m \"commit message\"提交代码。\n注意：git commit命令后面请加上-m选项，否则会进入VIM模式，非常不方便。\n5.7 创建Pull Request创建Pull Request包括创建新的Pull Request、查看Pull Request列表、合并Pull Request。\n\n创建新的Pull Request：点击仓库的“Pull requests”标签，点击“New pull request”按钮，选择“compare across forks”或“compare with head branch”，选择“base: master”、“head: new-branch”、“Reviewers”、“Assignees”、“Labels”、“Projects”、“Milestone”等信息，点击“Create pull request”按钮。\n查看Pull Request列表：点击仓库的“Pull requests”标签，可以看到所有Pull Request的列表。\n合并Pull Request：点击Pull Request的“Merge pull request”按钮，选择“Confirm merge”按钮，完成合并。\n\n6. 其他6.1 “魔法”由于GitHub是外部网站，所以稳定打开需要使用“魔法”，但只是打开梯子后向GitHub通过Git提交代码并不会像打开GitHub网站一样畅通，您需要配置Git相关端口才能实现梯子端口下Git提交代码。\n6.2 插件在VSCode上Git相关的插件有很多，这里向您强烈推荐GitLens这款插件。它的可视化界面可以帮助您便捷地查看代码的历史记录、文件修改历史、提交记录、分支管理、GitHub上Pull Request等常用Git操作。\n如您有使用其他相关插件的经验或者推荐，欢迎在评论区交流分享❤。\n6.3 提交规范详见博客帖子 Angular 提交规范详解。\n7. 总结Git已成为目前最流行的版本控制工具，是开发者必备的技能。Git可以帮助您管理代码的历史记录、团队协作、代码分享、备份等。Git与GitHub的结合可以让您在线管理你的代码，并为与他人合作提供便利。\n希望本文对您有所帮助，祝您学习与生活愉快！😘✨💖\n","slug":"git-tutorial","date":"2025-03-08T13:23:57.000Z","categories_index":"工作","tags_index":"技术,Git,版本控制,GitHub,必备","author_index":"Proselyte"},{"id":"c57ac7e007501b2d3bc006029389c13c","title":"十分钟上手Markdown","content":"十分钟上手MarkdownPS.学习Markdown对您的代码水平没有任何要求，零代码基础也可以轻松上手。\n1. 什么是Markdown？为什么要使用Markdown？\n\n\n\n\n\n\n\n\nMarkdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。\n以上文字摘自Markdown官方教程 markdown.com.cn。\n鉴于高效简洁的Markdown在程序员后续工作中合作场景的广泛应用且其上手容易，建议您花费十分钟时间掌握这门技能，并在日后工作中多使用锻炼，熟能生巧。\n2. Markdown怎么写？Markdown书写于后缀为.md的文件中，语法简单，易于上手，是一种通过引入简单的符号来标记文本的语言。接下来将介绍一些常用的语法，详细及进阶语法请参考官方教程 markdown.com.cn。您可以在VSCode这款强大的编辑器或者Arya等在线编辑器中进行Markdown的编写。\n接下来建议您遵循以下步骤进行操作练习：\n\n安装并打开VSCode编辑器。\n建议您安装Markdown All in One、Markdown Lint以及Markdown Preview Enhanced这三个插件。\n在合适的位置新建一个test.md文件作为练习文件。\n打开test.md文件，右键选择MPE：打开侧边预览预览编辑效果。\n跟随后续教程在编辑器中输入Markdown语法，并对照预览效果进行理解记忆。\n\n2.1 标题标题是Markdown中最重要的语法之一，通过在行首插入1-6个#来表示不同级别的标题，#的数量表示标题的级别。\n123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n2.2 强调通过将文本设置为粗体或斜体来强调其重要性。\n12345*斜体***粗体*****粗体加斜体***\n\n2.3 换行与分段在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(&lt;br&gt;)。注意：markdown中可以使用HTML中的&lt;br&gt;标签来实现换行。\n12这是第一行。  这是第二行。\n\n在Markdown中，分段是通过空白行来实现的。注意：不要用空格（spaces）或制表符（ tabs）缩进段落！\n123段落1段落2\n\n2.4 分隔线分隔线可以通过三个或三个以上的星号、减号、下划线来实现。\n123---***___\n\n2.5 列表无序列表ul通过星号、加号或减号来实现，有序列表ol则通过数字加句点来实现。\n123456* 第一项* 第二项* 第三项1. 第一项2. 第二项3. 第三项\n\n2.6 引用与代码引用通过在段落前面添加&gt;符号来实现。\n1&gt; 这是一个引用。\n\n要将单词或短语表示为代码，请将其包裹在反引号 (`) 中。如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(``)中。\n123Use `code` in your Markdown file.``Use `code` in your Markdown file.``\n\n代码块的引入需要在代码前后分别添加三个反引号（```），可以声明其语言类型。注意：下面代码示例中每行去掉前面的反斜杠\\后为实际语法。\n123\\``` python\\print(\"Hello, World!\")\\```\n\n2.7 链接与图片链接通过方括号[]和圆括号()来实现。而图片的引入类似链接，只需在链接前加上!，并在方括号中添加图片的alt和title属性。\n123[链接名称](链接地址)![图片alt](图片链接 \"图片title\")\n\n3. 总结Markdown是一种简单易用的标记语言，高效、简洁、易读、易写，是程序员和写作爱好者的必备技能。以上介绍了Markdown的标题、强调、换行、分段、分隔线、列表、引用、代码、链接、图片等语法，希望能帮助您快速上手。转义字符、内嵌HTML等较复杂语法及详细语法请参考官方教程 markdown.com.cn。\n希望本文对您有所帮助，祝您学习与生活愉快！😘✨💖\n","slug":"markdown-tutorial","date":"2025-03-07T08:12:00.000Z","categories_index":"工作","tags_index":"教程,技术,Markdown","author_index":"Proselyte"},{"id":"3324aff7d1b50911304aa0367fc3a2fa","title":"初创博客所感","content":"从大学想到性格又想到WEB还有未来的发展最后扣题想了博客，瞎扯了很多。愿我能将这份热情与感慨留得久一点，跟随自我，不负初心……\n\n虽然实际建站（搭建+配置主题+部署）花费的时间很短（在AI的帮助下大概只用了不到两个小时？），但是考虑有自己的博客的想法还是很早很早就有了的。现在回想起来，大学那种很普遍的迷茫感与焦虑感或许是一直阻碍那个想法变成现实的最大敌人。\n从迈进大一的那一刻，我脑海中还记得之前被灌输的那种思想——就是一定要把目标定的高远。高中时，无论成绩怎样，目标永远是清北；大学了，还没上课，目标就想着保研，却连研究生是什么、要干什么、适不适合我的发展都一点也不知道（有点可笑）。诚然，这种想法的方向没什么大问题，如果一个人的目标一直很低、一直囿于现状，那他/她至少不会过得更好。\n但是我不觉得这种思想多么适合我。虽然我是一个满脑子想法、渴望自由、不喜欢被约束的人，但我也是一个有野心、更渴望通过自己的成就赢得他人认可的人。我确实有一点拖延症，但是每次都一定会提前一会把事情做好，我并不需要一个高远的目标如同达摩克里斯之剑一样悬在我的头顶，反倒是它的寒光让我目眩。我也确实因为它而时常陷入内耗与焦虑的漩涡之中。\n现在是大二下学期刚开始，如果让我总结这一年半的收获，那大概是：\n\n还算可以地听了课，打好了编程基础。\n结交了许多朋友，从学长、学姐那里学到了很多宝贵的经验和方法。\n学会了查找资料、使用AI等自我学习的非常多的方法，自学效率大大提升。\n还有最重要的——不再稀里糊涂地活在过去和当下之间，对未来有了自己的规划和认识，从而不再在内耗和焦虑中迷失。\n\n在OurEDA学习WEB的日子并没有想象中顺利：第一次普通前端三件套Wordle的作业写得不错 -&gt; 学React框架的那次因为备考没时间而抄了同学的（基本没怎么改），被公开处刑，差点就寄了 -&gt; 知耻而后勇，重新补上了落下的内容，自己也加大投入，后面的作业都完成度很高 -&gt; 现在比较有信心用自己的前端技术去实现一些想法。天知道中间那段时间有多难熬。\n从一开始我在Wordle中接触前端的那一刻，我就感觉它好像与我命中注定相关，很难想象一个我梦寐以求如何实现的小游戏的样式在几行代码下就勾勒出来，更让我着迷的的当然还有那些精妙的交互、动画、设计，以及在连通的那一刻收到200响应的感觉，似乎我就是在地球上第一次听到远在月球的阿姆斯特朗的声音的人。因此上手前端对我来说确实就是兴趣使然，但是后来那种急于实践、缺少耐心阅读文档和观看长视频的习惯以及课程压力逐渐让我有些力不从心。我仍记得当初的浏览器开着十几个学习页面，每个页面都看不了几眼又烦躁地去看别的。现在想想，那时大概也是没有一个清晰地整体认识就盲目去做的后果吧。\n技术更迭迅速、敏捷开发一直是前端行业的特点，选择什么技术栈、去学习新的技术栈还是用已有的去做永远是需要权衡的问题。经过这个寒假自己开发过程中总结的经验教训，我也有了更深刻的体会。总结下来，减少纠结、清晰了解、抓紧去干才是硬道理，而技术栈的选择永远不是最重要的，至少，在选择中一味纠结是贻害无穷的。\n因此，当这一次我决定开始搭自己的博客网站也比较坚定地打消了之前的迷茫，放弃了纯自己手搓来练手炫技（装*）那种费时的方案（后续写portfolio可能会手搓），而是选择了用现成的工具、模板来快速搭建，更注重写博客本身对我个人反思总结以及提升的意义。我暂窃以为这才不是舍本逐末、买椟还珠，而是契合初衷的正确选择。\n这个学期课程要少很多（由于给100意愿值的sb劳动2离谱地掉了！！！），也正是提升自我的好时机，与wzy学长交流之后感觉收获颇丰，也又一次对未来发展包括求职有了更深的理解。希望能把握机会积极去实践，享受勇敢去做的快感。也希望我能把博客坚持运营下去，帮助自己和更多的人，一同成长，一同进步。\n愿我将来如果失去动力、感到迷茫时，看到这篇感悟、看到那个热血沸腾的自己，能振奋起来，重拾信心，继续前行！\n","slug":"thoughts-on-starting-blogging","date":"2025-03-06T12:08:21.000Z","categories_index":"生活","tags_index":"随笔","author_index":"Proselyte"},{"id":"5bc5ed974c3e283a48cd798b95da315a","title":"学习资源推荐","content":"一、网站1.工具\nPPT模板素材 第一PPT\n图标素材 阿里iconfont\nreadme中文模板 shaojintian/Best_README_template\n免费高质量图片素材 pixabay\n免费UI组件库 antd\n强大的免费PDF操作工具 ilovepdf\n页面制作灵感 awwwards\n免费电子书平台 z-library\nlatex线上编辑器 overleaf\n强大的免费GIF操作工具 ezgif\n3D模型素材 sketchfab\n免费音频素材 freesound\n免费字体素材 dafont\n免费音效素材 freesound\n免费视频图片素材 pexels\n\n2.学习\n编程学习 菜鸟教程\nAI提示词训练 阿里AI提示词训练\nWEB文档 mdn\n\n3.前端库\n3D效果 three.js\n动画 motion.js\n邮箱 emailjs\n地图 React Simple Maps\n富文本编辑器 Quill\n2D效果 pixi.js\n图表 chart.js\n截图 html2canvas\n二维码 qrcode.js\n打字机效果 typewriterjs ityped\n\n二、视频\n互联网岗位介绍 【2024最新】互联网岗位介绍及其建议分析 码路漫漫谈(B站)\nJavaScript高级教程 coderwhy最强JavaScript高级教程 coderwhy官方账号(B站)\n进制转换 【最强干货】详解二进制，八进制，十进制，十六进制的相互转换 我是2045(B站)\nvscode中配置c/c++ vscode安装配置c/c++教程vscode安装使用教程 改BUG的TOM学长(B站)\n动画阐释各种排序算法 动画阐释各种排序算法（之前误删了大家也不用再点赞投币了）说数人V(B站)\nPPT教程 PPT教程 | PPT高手之路，零基础做出高逼格PPT，免费PPT设计制作技巧教学！OFFICE/WPS/演示/幻灯片/PPT模板/keynote/汇报/总结 珞珈PPT(B站)\n\n三、博主\n前端项目实战 Lama Dev(油管)\n100s技术快闪 Fireship(油管)\n像素画制作 AdamCYounis(油管)\nUI设计 Flux Academy(油管) UXTools(油管)\n编程教程 Web Dev Simplified(油管) Net Ninja(油管) Programming with Mosh(油管)\nCSS技巧 Lun Dev(油管)\n\n","slug":"resources-recommendation","date":"2025-03-06T02:00:27.000Z","categories_index":"工作","tags_index":"技术,推荐","author_index":"Proselyte"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2025-03-05T13:23:50.933Z","categories_index":"工作","tags_index":"技术,Hexo","author_index":"Proselyte"}]