{"title":"JS 循环遍历合集","uid":"98911f92eb694bc1fa709c4da7b8f328","slug":"js-loop-all-in-one","date":"2025-11-03T10:31:34.000Z","updated":"2025-11-10T05:48:05.221Z","comments":true,"path":"api/articles/js-loop-all-in-one.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-js.png","content":"<h1 id=\"JS-循环遍历合集\"><a href=\"#JS-循环遍历合集\" class=\"headerlink\" title=\"JS 循环遍历合集\"></a>JS 循环遍历合集</h1><p>JS 中可以遍历的数据结构主要是数组和对象，实现方案有循环 <code>for</code>、<code>for...in</code>、<code>for...of</code>、<code>forEach</code>、<code>while</code>、<code>do...while</code> 及方法 <code>map</code>、<code>reduce</code>、<code>filter</code> 等等。</p>\n<p>下面对这些方法进行一个总结，并对于它们的区别进行对比、对于深层的迭代器机制进行讲解。</p>\n<h2 id=\"一、循环\"><a href=\"#一、循环\" class=\"headerlink\" title=\"一、循环\"></a>一、循环</h2><h3 id=\"for-与-while\"><a href=\"#for-与-while\" class=\"headerlink\" title=\"for 与 while\"></a>for 与 while</h3><p><code>for</code> 与 <code>while</code> 或 <code>do...while</code> 是最基础的循环方式，与其他语言中类似。</p>\n<p>需注意 <code>var</code> 与 <code>let</code> 或 <code>const</code> 的作用域问题，循环结构形成了<strong>块级作用域</strong>。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用 var 不能形成作用域</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; btns.<span class=\"property\">length</span>; a++) {</span><br><span class=\"line\">  btns[a].<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 5 5 5 5 5 以前必须使用立即执行函数来解决这一问题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 块级作用域</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> a = <span class=\"number\">0</span>; a &lt; btns.<span class=\"property\">length</span>; a++) {</span><br><span class=\"line\">  btns[a].<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a);</span><br><span class=\"line\">  };</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 0 1 2 3 4 现在可以使用 let 的块级作用域解决</span></span><br><span class=\"line\"></span><br><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"comment\">// 以上循环逻辑相当于定义了五个块级作用域</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> item <span class=\"keyword\">of</span> items) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 这种写法可以使用 const 来声明块级作用域</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"迭代协议（Iteration-Protocol）\"><a href=\"#迭代协议（Iteration-Protocol）\" class=\"headerlink\" title=\"迭代协议（Iteration Protocol）\"></a>迭代协议（Iteration Protocol）</h3><p>迭代协议并不是新的内置实现或语法，而是<strong>协议</strong>。这些协议可以被任何遵循某些约定的对象来实现。</p>\n<p>迭代协议具体分为两个协议：<strong>可迭代协议</strong>和<strong>迭代器协议</strong>。</p>\n<h4 id=\"可迭代协议（Iterable-Protocol）\"><a href=\"#可迭代协议（Iterable-Protocol）\" class=\"headerlink\" title=\"可迭代协议（Iterable Protocol）\"></a>可迭代协议（Iterable Protocol）</h4><p>可迭代协议允许 JavaScript 对象定义或定制它们的迭代行为，一些内置类型同时是内置的可迭代对象，并且有默认的迭代行为，比如 <code>Array</code> 或者 <code>Map</code>，而其他内置类型则不是（比如 <code>Object</code>）。</p>\n<p>要成为可迭代对象，该对象必须实现 <code>[Symbol.iterator]()</code> 方法，这意味着对象（或者它原型链上的某个对象）必须有一个键为 <code>[Symbol.iterator]</code> 的属性，可通过常量 <code>Symbol.iterator</code> 访问该属性：</p>\n<p><code>[Symbol.iterator]</code>：一个无参数的函数，其返回值为一个符合迭代器协议的对象。</p>\n<p>当一个对象需要被迭代的时候，首先，会不带参数调用它的 <code>[Symbol.iterator]()</code> 方法，然后使用此方法返回的迭代器获得要迭代的值。</p>\n<p>值得注意的是调用此无参数函数时，它将作为对可迭代对象的方法进行调用。因此，在函数内部，this 关键字可用于访问可迭代对象的属性，以决定在迭代过程中提供什么。</p>\n<p>此函数可以是普通函数，也可以是生成器函数，以便在调用时返回迭代器对象。在此生成器函数的内部，可以使用 yield 提供每个条目。</p>\n<h3 id=\"for…in-与-for…of-与-forEach\"><a href=\"#for…in-与-for…of-与-forEach\" class=\"headerlink\" title=\"for…in 与 for…of 与 forEach\"></a>for…in 与 for…of 与 forEach</h3><p>这三种方式是 ES6 中新增的基于 <code>for</code> 的循环遍历方案，能够针对数组和对象的不同进行针对性的遍历。</p>\n<h4 id=\"1-for…in\"><a href=\"#1-for…in\" class=\"headerlink\" title=\"1. for…in\"></a>1. for…in</h4><h4 id=\"2-for…of\"><a href=\"#2-for…of\" class=\"headerlink\" title=\"2. for…of\"></a>2. for…of</h4><h4 id=\"3-forEach\"><a href=\"#3-forEach\" class=\"headerlink\" title=\"3. forEach\"></a>3. forEach</h4><p><code>forEach</code> 是专用于数组中遍历的方案。</p>\n<h3 id=\"遍历方法\"><a href=\"#遍历方法\" class=\"headerlink\" title=\"遍历方法\"></a>遍历方法</h3>","text":"JS 循环遍历合集JS 中可以遍历的数据结构主要是数组和对象，实现方案有循环 for、for...in、for...of、forEach、while、do......","permalink":"/post/js-loop-all-in-one","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JS-%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E5%90%88%E9%9B%86\"><span class=\"toc-text\">JS 循环遍历合集</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">一、循环</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for-%E4%B8%8E-while\"><span class=\"toc-text\">for 与 while</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE%EF%BC%88Iteration-Protocol%EF%BC%89\"><span class=\"toc-text\">迭代协议（Iteration Protocol）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%8D%8F%E8%AE%AE%EF%BC%88Iterable-Protocol%EF%BC%89\"><span class=\"toc-text\">可迭代协议（Iterable Protocol）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#for%E2%80%A6in-%E4%B8%8E-for%E2%80%A6of-%E4%B8%8E-forEach\"><span class=\"toc-text\">for…in 与 for…of 与 forEach</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-for%E2%80%A6in\"><span class=\"toc-text\">1. for…in</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-for%E2%80%A6of\"><span class=\"toc-text\">2. for…of</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-forEach\"><span class=\"toc-text\">3. forEach</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">遍历方法</span></a></li></ol></li></ol></li></ol>","author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"cors-solving","uid":"a54cbac13e0374f178fc688cf2f20720","slug":"cors-solving","date":"2025-11-03T10:32:56.000Z","updated":"2025-11-10T06:51:00.300Z","comments":true,"path":"api/articles/cors-solving.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cors-solving/cover.png","text":"","permalink":"/post/cors-solving","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"http 与 https 详解","uid":"f6a6b4e0c6933074477ff6776441820b","slug":"http-and-https","date":"2025-10-31T01:24:13.000Z","updated":"2025-11-10T06:41:17.080Z","comments":true,"path":"api/articles/http-and-https.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/http-and-https/cover.png","text":"http 与 https 详解二、面试简述HTTP基础HTTP 超文本传输协议，应用层协议。主要用于 Web 上传输超媒体文本的底层协议，经常在浏览器和服务器之...","permalink":"/post/http-and-https","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"工作","slug":"工作","count":11,"path":"api/categories/工作.json"}],"tags":[{"name":"http","slug":"http","count":1,"path":"api/tags/http.json"},{"name":"https","slug":"https","count":1,"path":"api/tags/https.json"},{"name":"互联网","slug":"互联网","count":1,"path":"api/tags/互联网.json"},{"name":"协议","slug":"协议","count":1,"path":"api/tags/协议.json"},{"name":"面试","slug":"面试","count":3,"path":"api/tags/面试.json"},{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/tags/计算机网络.json"}],"author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}