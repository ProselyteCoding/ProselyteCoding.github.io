{"title":"JS高级-1-执行机制与作用域","uid":"194d5c5216aeb653976ea78ea0fb0315","slug":"js-premier-1-executions-and-scoops","date":"2025-07-16T09:48:12.000Z","updated":"2025-07-21T14:45:22.355Z","comments":true,"path":"api/articles/js-premier-1-executions-and-scoops.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-js.png","content":"<h1 id=\"JS-高级-1-执行机制与作用域\"><a href=\"#JS-高级-1-执行机制与作用域\" class=\"headerlink\" title=\"JS 高级-1-执行机制与作用域\"></a>JS 高级-1-执行机制与作用域</h1><h2 id=\"一、浏览器运行与-V8-引擎\"><a href=\"#一、浏览器运行与-V8-引擎\" class=\"headerlink\" title=\"一、浏览器运行与 V8 引擎\"></a>一、浏览器运行与 V8 引擎</h2><h3 id=\"1-JS-在浏览器中的运行原理\"><a href=\"#1-JS-在浏览器中的运行原理\" class=\"headerlink\" title=\"1. JS 在浏览器中的运行原理\"></a>1. JS 在浏览器中的运行原理</h3><p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/1.png\" alt=\"浏览器下载与运行流程\"></p>\n<p>流程：域名 -&gt; DNS 解析 -&gt; IP 地址(服务器地址) -&gt; 返回 index.html -&gt; 遇见标签下载对应的文件(CSS/JS) -&gt; 执行 JS 代码</p>\n<h3 id=\"2-浏览器内核与渲染\"><a href=\"#2-浏览器内核与渲染\" class=\"headerlink\" title=\"2. 浏览器内核与渲染\"></a>2. 浏览器内核与渲染</h3><p><strong>浏览器内核：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/2.png\" alt=\"浏览器内核\"></p>\n<p><strong>浏览器渲染：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/3.png\" alt=\"浏览器渲染\"></p>\n<h3 id=\"3-JS-引擎-V8-引擎\"><a href=\"#3-JS-引擎-V8-引擎\" class=\"headerlink\" title=\"3. JS 引擎(V8 引擎)\"></a>3. JS 引擎(V8 引擎)</h3><p><strong>认识 JS 引擎：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/4.png\" alt=\"认识JS引擎\"></p>\n<p><strong>浏览器内核和 JS 引擎的关系：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/5.png\" alt=\"浏览器内核和JS引擎的关系\"></p>\n<p><strong>V8 引擎的原理：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/6.png\" alt=\"V8引擎的原理\"></p>\n<p><strong>V8 引擎的架构：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/7.png\" alt=\"V8引擎的架构\"></p>\n<p><strong>V8 引擎的解析图(官方)：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/8.png\" alt=\"V8引擎的解析图(官方)\"></p>\n<p><strong>V8 执行的细节：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/9.png\" alt=\"V8执行的细节\"></p>\n<h2 id=\"二、代码执行与作用域提升\"><a href=\"#二、代码执行与作用域提升\" class=\"headerlink\" title=\"二、代码执行与作用域提升\"></a>二、代码执行与作用域提升</h2><h3 id=\"1-JS-代码的执行\"><a href=\"#1-JS-代码的执行\" class=\"headerlink\" title=\"1. JS 代码的执行\"></a>1. JS 代码的执行</h3><h4 id=\"ECStack-、GO、EC、VO、AO\"><a href=\"#ECStack-、GO、EC、VO、AO\" class=\"headerlink\" title=\"ECStack 、GO、EC、VO、AO\"></a>ECStack 、GO、EC、VO、AO</h4><p>浏览器会在计算机内存中分配一块内存，专门用来供代码执行的栈内存，称作<strong>执行环境栈 (ECStack)</strong> 同时会创建一个 <strong>全局对象(GO)</strong>，将内置的属性方法( isNaN、setInterval、setTimeout… )存放到一块单独的堆内存空间，并且使用 <code>window</code> 指向全局对象。</p>\n<p>在执行代码前，还需要创建一个<strong>全局执行上下文( EC(G) )</strong>, 创建完成后，进入到栈内存中去执行(进栈)；在当前全局执行上下文中，因为会创建很多变量并且赋值，所以会创建一个<strong>变量对象 VO(Varibale Object)</strong> 来进行保存，在函数私有上下文中的变量对象叫做 <strong>活动对象 AO(Activation Object)</strong> （ps: 每个执行上下文都有一个单独的变量对象）。</p>\n<p>总结一下：</p>\n<ul>\n<li>执行环境栈(<strong>ECStack</strong>)：专门用来供代码执行的 栈内存</li>\n<li>全局对象(<strong>GO</strong>)：存放内置的属性方法，window 指向</li>\n<li>全局执行上下文( <strong>EC(G)</strong> )：页面加载后进栈、销毁后出栈</li>\n<li>变量对象<strong>VO</strong>(Variable Object)： 存放当前执行上下文中创建的变量和值</li>\n<li>活动对象<strong>AO</strong>(Activation Object)： 函数私有上下文中的变量对象</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/1.gif\" alt=\"ECStack 、GO、EC、VO、AO\"></p>\n<h4 id=\"全局代码执行\"><a href=\"#全局代码执行\" class=\"headerlink\" title=\"全局代码执行\"></a>全局代码执行</h4><p>当一切准备就绪，就开始从上到下执行代码 (ps: 执行前还会涉及变量提升的问题，这里不进行展开)</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">12</span>, <span class=\"number\">23</span>];</span><br></pre></td></tr></tbody></table></figure>\n\n<p>js 在解析这段代码时，会按照以下 3 个步骤</p>\n<ol>\n<li>先创建一个值 [12, 23]</li>\n<li>再创建一个变量 x</li>\n<li>最后将变量与值进行关联</li>\n</ol>\n<p>当创建的值是引用类型时，会在堆内存中开辟新的内存空间用了保存值，创建完成后，会将堆内存地址(通常是 16 进制 )保存到栈内存中； 如果创建的值是基本类型时，会直接保存到栈内存中</p>\n<p><video src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/2.mp4\" controls=\"controls\" width=\"1000\" height=\"600\"></video></p>\n<p>在函数创建好后，继续向下执行</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fn</span>(x);</span><br></pre></td></tr></tbody></table></figure>\n\n<p>通过上面的动图了解到，fn 和 x 都指向堆内存地址，所以，fn(x) 相当于 AAAFFF000(AAAFFF111) , 在执行函数体代码之前，我们需要知道的是：</p>\n<ul>\n<li>每次函数执行，都会创建一个函数私有执行上下文，创建完之后，需要进入到栈内存中去执行，此时，执行栈中的全局执行上下文就会被压入到栈底(压栈)</li>\n<li>同时，需要创建一个活动对象 AO 存放当前函数执行上下文中创建的变量和值等</li>\n</ul>\n<p><video src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/3.mp4\" controls=\"controls\" width=\"1000\" height=\"600\"></video></p>\n<p>在完成函数执行上下文入栈后，接下来会做以下几件事</p>\n<ul>\n<li>初始化作用域链 scopeChain: 作用域链通常标记为 &lt;当前执行上下文, 函数创建时的作用域&gt; ，而作用域链是为了函数执行过程中，当活动对象中不存在某个变量时，会沿着作用域链向上找到</li>\n<li>初始化 <code>this</code> 指向: 本例子中，<code>this</code> 等于 <code>window</code></li>\n<li>初始化实参集合 arguments</li>\n<li>形参赋值 <code>y = x = AAAFFF111</code></li>\n<li>执行函数体 紧接着就是执行函数体内容，在执行完成后，当前函数的执行上下文就会出栈，退出执行栈，而被压入栈底的全局执行上下文又被推到了栈顶，此时会继续执行全局上下文中的代码</li>\n</ul>\n<p><video src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/4.mp4\" controls=\"controls\" width=\"1000\" height=\"600\"></video></p>\n<p>至此，代码执行结束，最终输出的 <code>x</code> 是 <code>[100, 23]</code>。</p>\n<h2 id=\"三、函数执行与作用域链\"><a href=\"#三、函数执行与作用域链\" class=\"headerlink\" title=\"三、函数执行与作用域链\"></a>三、函数执行与作用域链</h2><p>函数执行时，除了会创建函数私有执行上下文外，还会创建一个作用域链，作用域链是为了在函数执行过程中，能够找到变量的值。</p>\n<p>作用域链的创建过程如下：</p>\n<ol>\n<li>创建函数私有执行上下文时，首先会创建一个作用域链 scopeChain</li>\n<li>作用域链通常标记为 <code>&lt;当前执行上下文, 函数创建时的作用域&gt;</code></li>\n<li>当函数执行时，作用域链会沿着作用域链向上找到变量的值</li>\n<li>如果在当前执行上下文中找不到变量，则会沿着作用域链向上查找，直到找到全局执行上下文</li>\n<li>如果全局执行上下文中也找不到变量，则会抛出错误</li>\n</ol>\n<p><em>注意：作用域链在编译时创建，而与之后的调用位置无关，即便后来函数嵌套调用，其父级作用域仍为初始状态而不一定是外层函数。</em></p>\n<p><strong>变量提升</strong>：指在函数执行前，变量会被提升到函数的顶部，但不会提升赋值操作。</p>\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 变量提升示例</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">fn</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>; <span class=\"comment\">// 变量提升</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 10</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">fn</span>();</span><br></pre></td></tr></tbody></table></figure>\n\n<p>其本质为编译时创建的变量对象 VO 或 AO 中的变量添加了该属性，但还未执行赋值操作，因此其值为 <code>undefined</code>，但是存在该属性。</p>\n<h2 id=\"四、相关面试题\"><a href=\"#四、相关面试题\" class=\"headerlink\" title=\"四、相关面试题\"></a>四、相关面试题</h2><figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  n = <span class=\"number\">200</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n); <span class=\"comment\">// 200</span></span><br><span class=\"line\"><span class=\"comment\">/* 解释：函数foo中不存在变量n</span></span><br><span class=\"line\"><span class=\"comment\"> 因此执行时，n被提升到全局作用域中，找到，赋值200 */</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第二题</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">200</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n); <span class=\"comment\">// 200</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"comment\">/* 解释：函数foo中声明了变量n，AO中n初始为undefined</span></span><br><span class=\"line\"><span class=\"comment\"> 因此执行到第一次打印时结构为undefined</span></span><br><span class=\"line\"><span class=\"comment\"> 接着执行n = 200赋值，最后输出200</span></span><br><span class=\"line\"><span class=\"comment\"> 此题中没有进行变量提升 */</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第三题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo1</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n); <span class=\"comment\">// 100</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo2</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">200</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n); <span class=\"comment\">// 200</span></span><br><span class=\"line\">  <span class=\"title function_\">foo1</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo2</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(n); <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"comment\">/* 解释：全局作用域中的n被声明后在执行时赋值为100</span></span><br><span class=\"line\"><span class=\"comment\"> 函数foo1的父级作用域为全局作用域</span></span><br><span class=\"line\"><span class=\"comment\"> 而其中没有声明变量n，因此会沿着作用域链向上查找，找到全局作用域中的n，输出100</span></span><br><span class=\"line\"><span class=\"comment\"> 函数foo2中声明了变量n，先生成属性n为undefined的AO，再赋值为200，因此在foo2中输出200</span></span><br><span class=\"line\"><span class=\"comment\"> foo2执行完后，最后打印的是全局作用域中的n，foo2未对其进行修改，输出100 */</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第四题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">200</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"comment\">/* 解释：即使 return 后面的代码只在执行时运行，也能声明变量</span></span><br><span class=\"line\"><span class=\"comment\"> 因为函数foo中声明了变量a，AO中a初始为undefined</span></span><br><span class=\"line\"><span class=\"comment\"> 因此执行foo时，找到AO中的a，打印undefined</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></tbody></table></figure>\n\n<figure class=\"highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第五题</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = (b = <span class=\"number\">100</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"comment\">/* 解释：var a = b = 100 等价于 var a = 100 和 b = 100 这两条代码</span></span><br><span class=\"line\"><span class=\"comment\"> 因此函数foo中声明了变量a，AO中a初始为undefined</span></span><br><span class=\"line\"><span class=\"comment\"> 而b没有使用var、let、const声明，因此b被提升到全局作用域中</span></span><br><span class=\"line\"><span class=\"comment\"> 等价于在全局作用域中执行 var b = 100</span></span><br><span class=\"line\"><span class=\"comment\"> 因此在全局作用域中打印a时输出undefined，而打印b时输出100 */</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h2 id=\"五、内存管理和-GC-垃圾回收算法\"><a href=\"#五、内存管理和-GC-垃圾回收算法\" class=\"headerlink\" title=\"五、内存管理和 GC 垃圾回收算法\"></a>五、内存管理和 GC 垃圾回收算法</h2><p><strong>认识内存管理：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/10.png\" alt=\"认识内存管理\"></p>\n<p><strong>JS 的内存管理：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/11.png\" alt=\"JS的内存管理\"></p>\n<p><strong>JS 的垃圾回收：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/12.png\" alt=\"JS的垃圾回收\"></p>\n<p><strong>常用的 GC 算法：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/13.png\" alt=\"引用计数\"></p>\n<p><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/js-premier-1-executions-and-scoops/14.png\" alt=\"标记清除\"></p>\n<h2 id=\"六、总结\"><a href=\"#六、总结\" class=\"headerlink\" title=\"六、总结\"></a>六、总结</h2><p>这是 JS 高级教程笔记整理的第一篇，此后这个系列将整理我有关 B 站 coderwhy 最强 JavaScript 高级教程的学习笔记，之后会补充 JS 面试题总结。笔记顺序大概参照视频课程的顺序，部分只是要求了解的内容可能不进行整理。</p>\n<p>本文整理了 JS 的执行机制、作用域链、内存管理和垃圾回收等内容，帮助理解 JS 的运行原理和内存管理方式。让我眼前一亮的是面试题考察的作用域链和变量提升的细节，这也是对 JS 运行机制的深入理解，不得不说 JS 还是非常值得钻研学习的。</p>\n<p>参考内容：</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1gYpmeKEvt?spm_id_from=333.788.videopod.episodes&amp;vd_source=13be13cef40f3972c65f0af98bf87ea2\">coderwhy 最强 JavaScript 高级教程 1-15 集</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/311196297\">通过动图了解 JS 中的 ECStack、EC、VO 和 AO</a></li>\n</ul>\n","text":"JS 高级-1-执行机制与作用域一、浏览器运行与 V8 引擎1. JS 在浏览器中的运行原理 流程：域名 -> DNS 解析 -> IP 地址(服务器地址) -...","permalink":"/post/js-premier-1-executions-and-scoops","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"工作","slug":"工作","count":15,"path":"api/categories/工作.json"}],"tags":[{"name":"技术","slug":"技术","count":11,"path":"api/tags/技术.json"},{"name":"前端","slug":"前端","count":9,"path":"api/tags/前端.json"},{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/tags/JavaScript.json"},{"name":"面试","slug":"面试","count":1,"path":"api/tags/面试.json"},{"name":"笔记","slug":"笔记","count":2,"path":"api/tags/笔记.json"},{"name":"进阶","slug":"进阶","count":2,"path":"api/tags/进阶.json"},{"name":"执行机制","slug":"执行机制","count":1,"path":"api/tags/执行机制.json"},{"name":"作用域","slug":"作用域","count":1,"path":"api/tags/作用域.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JS-%E9%AB%98%E7%BA%A7-1-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">JS 高级-1-执行机制与作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%90%E8%A1%8C%E4%B8%8E-V8-%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">一、浏览器运行与 V8 引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-JS-%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1. JS 在浏览器中的运行原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E4%B8%8E%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">2. 浏览器内核与渲染</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-JS-%E5%BC%95%E6%93%8E-V8-%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">3. JS 引擎(V8 引擎)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">二、代码执行与作用域提升</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-JS-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">1. JS 代码的执行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ECStack-%E3%80%81GO%E3%80%81EC%E3%80%81VO%E3%80%81AO\"><span class=\"toc-text\">ECStack 、GO、EC、VO、AO</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%B1%80%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">全局代码执行</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE\"><span class=\"toc-text\">三、函数执行与作用域链</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">四、相关面试题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C-GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">五、内存管理和 GC 垃圾回收算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">六、总结</span></a></li></ol></li></ol>","author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"CSS水平居中样式的8种实现方式","uid":"0ef5e478d063e387bdfd27538e830494","slug":"css-horizontal-center-in-eight-ways","date":"2025-07-17T10:31:03.000Z","updated":"2025-07-17T12:28:45.288Z","comments":true,"path":"api/articles/css-horizontal-center-in-eight-ways.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-css.png","text":"CSS 水平居中样式的8种实现方式假设需要设置水平居中样式的对象是 item ，其父元素为 container 1. text-align: center行内元...","permalink":"/post/css-horizontal-center-in-eight-ways","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[{"name":"工作","slug":"工作","count":15,"path":"api/categories/工作.json"}],"tags":[{"name":"技术","slug":"技术","count":11,"path":"api/tags/技术.json"},{"name":"前端","slug":"前端","count":9,"path":"api/tags/前端.json"},{"name":"CSS","slug":"CSS","count":4,"path":"api/tags/CSS.json"},{"name":"样式","slug":"样式","count":1,"path":"api/tags/样式.json"},{"name":"水平居中","slug":"水平居中","count":1,"path":"api/tags/水平居中.json"},{"name":"总结","slug":"总结","count":2,"path":"api/tags/总结.json"}],"author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"前端尺寸单位总结","uid":"de29ad04e0c0a4f4e4f4656db4c38b06","slug":"dimmensional-units-summary","date":"2025-07-11T12:28:26.000Z","updated":"2025-07-17T16:45:16.099Z","comments":true,"path":"api/articles/dimmensional-units-summary.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/dimmensional-units-summary/cover.png","text":"前端尺寸单位总结前端开发中对于标签元素的尺寸样式设置需要指定单位，如 px、em、rem、vh、rpx 等，本文将总结常用的前端尺寸单位及其使用场景。 一、概述...","permalink":"/post/dimmensional-units-summary","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"工作","slug":"工作","count":15,"path":"api/categories/工作.json"}],"tags":[{"name":"技术","slug":"技术","count":11,"path":"api/tags/技术.json"},{"name":"前端","slug":"前端","count":9,"path":"api/tags/前端.json"},{"name":"CSS","slug":"CSS","count":4,"path":"api/tags/CSS.json"},{"name":"总结","slug":"总结","count":2,"path":"api/tags/总结.json"},{"name":"设计","slug":"设计","count":2,"path":"api/tags/设计.json"},{"name":"尺寸单位","slug":"尺寸单位","count":1,"path":"api/tags/尺寸单位.json"},{"name":"合集","slug":"合集","count":1,"path":"api/tags/合集.json"},{"name":"学习笔记","slug":"学习笔记","count":3,"path":"api/tags/学习笔记.json"}],"author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}