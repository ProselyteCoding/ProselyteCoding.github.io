{"title":"JavaScript中的数据类型和数据结构","uid":"04360b551b06637f5a57592a7da7fdcb","slug":"js-data-structures","date":"2025-09-11T15:51:20.000Z","updated":"2025-09-15T00:53:24.916Z","comments":true,"path":"api/articles/js-data-structures.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-js.png","content":"<h1 id=\"JavaScript中的数据类型和数据结构\"><a href=\"#JavaScript中的数据类型和数据结构\" class=\"headerlink\" title=\"JavaScript中的数据类型和数据结构\"></a>JavaScript中的数据类型和数据结构</h1><p>数据类型和数据结构是编程中的基本概念，也是几乎掌握任何一门语言都要最先学习的，它的重要性与原理也常常被忽视。</p>\n<p>编程语言都有内置的数据结构，但各种编程语言的数据结构常有不同之处。本文尝试列出 JavaScript 语言中内置的数据结构及其属性。它们可以用来构建其他的数据结构。</p>\n<h2 id=\"动态类型和弱类型\"><a href=\"#动态类型和弱类型\" class=\"headerlink\" title=\"动态类型和弱类型\"></a>动态类型和弱类型</h2><p>JavaScript 是一门有着动态类型的动态语言。JavaScript 中的变量与任何特定值类型没有任何直接关联，任何变量都可以被赋值（和被重新赋值）为各种类型的值：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"number\">42</span>; <span class=\"comment\">// foo 现在是数字</span></span><br><span class=\"line\">foo = <span class=\"string\">\"bar\"</span>; <span class=\"comment\">// foo 现在是字符串</span></span><br><span class=\"line\">foo = <span class=\"literal\">true</span>; <span class=\"comment\">// foo 现在是布尔值</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>JavaScript 也是一门弱类型语言，这意味着当运算涉及不匹配的类型时，它允许<strong>隐式类型转换</strong>，而不是抛出类型错误。</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"number\">42</span>; <span class=\"comment\">// foo 是数字</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = foo + <span class=\"string\">\"1\"</span>; <span class=\"comment\">// JavaScript 将 foo 强制转换为字符串，因此可以将其与另一个操作数连接起来</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result); <span class=\"comment\">// 421</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>隐式强制转换是非常方便的，但当转换在不期望发生的地方发生时，或者与期望发生的方向不同时（例如，字符串转换为数字，而不是数字转换为字符串），就会产生难以捉摸的错误。对于 symbol 和 BigInt，JavaScript 有意禁止了某些隐式类型转换。</p>\n<h2 id=\"原始值\"><a href=\"#原始值\" class=\"headerlink\" title=\"原始值\"></a>原始值</h2><p>除了 Object 以外，所有的类型都定义了不可变的、在语言最底层直接表示的值。我们将这些类型的值称为<strong>原始值</strong>。</p>\n<p>除了 <code>null</code> 以外，所有的原始类型都可以使用 <code>typeof</code> 运算符进行测试。<code>typeof null</code> 返回 <code>\"object\"</code>，因此必须使用 <code>=== null</code> 来测试 <code>null</code>。</p>\n<p>除了 <code>null</code> 和 <code>undefined</code> 以外，所有的原始类型都有对应的对象包装类型，它们为处理原始值提供了有用的方法。例如，<code>Number</code> 对象提供了像 <code>toExponential()</code> 这样的方法。当在原始值上访问属性时，JavaScript 会自动将值包装成对应的包装对象，并访问对象上的属性。然而，在 <code>null</code> 或 <code>undefined</code> 上访问属性时，会抛出 <code>TypeError</code> 异常，这需要使用可选链运算符。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>typeof 返回值</th>\n<th>对象包装器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Null</td>\n<td>“object”</td>\n<td>不适用</td>\n</tr>\n<tr>\n<td>Undefined</td>\n<td>“undefined”</td>\n<td>不适用</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>“boolean”</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>“number”</td>\n<td>Number</td>\n</tr>\n<tr>\n<td>BigInt</td>\n<td>“bigint”</td>\n<td>BigInt</td>\n</tr>\n<tr>\n<td>String</td>\n<td>“string”</td>\n<td>String</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>“symbol”</td>\n<td>Symbol</td>\n</tr>\n</tbody></table>\n<p>对象包装器类的参考页面包含每个类型可用的方法和属性的更多信息，以及原始类型自身语义的详细描述。</p>\n<h3 id=\"Null-类型\"><a href=\"#Null-类型\" class=\"headerlink\" title=\"Null 类型\"></a>Null 类型</h3><p>Null 类型只有一个值：<code>null</code>。</p>\n<h3 id=\"Undefined-类型\"><a href=\"#Undefined-类型\" class=\"headerlink\" title=\"Undefined 类型\"></a>Undefined 类型</h3><p>Undefined 类型只有一个值：<code>undefined</code>。</p>\n<p>从概念上讲，<code>undefined</code> 表示值缺失，<code>null</code> 表示对象缺失（这也解释了 <code>typeof null === \"object\"</code>）。当某些东西没有值时，JavaScript 语言通常默认为 <code>undefined</code>：</p>\n<ul>\n<li>没有值的 return 语句（<code>return;</code>），隐式返回 <code>undefined</code>。</li>\n<li>访问不存在的对象属性（<code>obj.iDontExist</code>），返回 <code>undefined</code>。</li>\n<li>变量声明时没有初始化（<code>let x;</code>），隐式初始化为 <code>undefined</code>。</li>\n<li>许多像 <code>Array.prototype.find()</code> 和 <code>Map.prototype.get()</code> 的方法，当没有找到元素时，返回 <code>undefined</code>。</li>\n</ul>\n<p><code>null</code> 在核心语言中使用频率少得多。最重要的地方是原型链的末端，其次是与原型交互的方法，如 <code>Object.getPrototypeOf()</code>、<code>Object.create()</code> 等，接受或返回 <code>null</code> 而不是 <code>undefined</code>。</p>\n<p><code>null</code> 是一个关键字，但 <code>undefined</code> 是一个普通的标识符，这个标识符恰好是一个全局属性。实际上区别很小，因为 <code>undefined</code> 不应该被重新定义或者遮蔽。</p>\n<h3 id=\"Boolean-类型\"><a href=\"#Boolean-类型\" class=\"headerlink\" title=\"Boolean 类型\"></a>Boolean 类型</h3><p>Boolean 类型表示一个逻辑实体并且包括两个值：<code>true</code> 和 <code>false</code>。</p>\n<p>布尔值通常用于条件运算，包括三元运算符、<code>if...else</code>、<code>while</code> 等。</p>\n<h3 id=\"Number-类型\"><a href=\"#Number-类型\" class=\"headerlink\" title=\"Number 类型\"></a>Number 类型</h3><p>Number 类型是一种基于 IEEE 754 标准的双精度 64 位二进制格式的值。它能够存储 <code>2^-1074</code>（<code>Number.MIN_VALUE</code>）和 <code>2^1023 × (2 - 2^-52)</code>（<code>Number.MAX_VALUE</code>）之间的正浮点数，以及相同范围的负浮点数，但是它仅能安全地存储在 <code>-(2^53 − 1)</code>（<code>Number.MIN_SAFE_INTEGER</code>）到 <code>2^53 − 1</code>（<code>Number.MAX_SAFE_INTEGER</code>）范围内的整数。超出这个范围，JavaScript 将不能安全地表示整数；相反，它们将由双精度浮点近似值表示。你可以使用 <code>Number.isSafeInteger()</code> 检查一个数是否在安全的整数范围内。</p>\n<p>超出表示范围的值会自动转换：</p>\n<ul>\n<li>大于 <code>Number.MAX_VALUE</code> 的正值被转换为 <code>+Infinity</code>。</li>\n<li>小于 <code>Number.MIN_VALUE</code> 的正值被转换为 <code>+0</code>。</li>\n<li>小于 <code>-Number.MAX_VALUE</code> 的负值被转换为 <code>-Infinity</code>。</li>\n<li>大于 <code>-Number.MIN_VALUE</code> 的负值被转换为 <code>-0</code>。</li>\n</ul>\n<p><code>+Infinity</code> 和 <code>-Infinity</code> 行为类似于数学上的无穷大，但是有一些细微的区别；更多细节，参见 <code>Number.POSITIVE_INFINITY</code> 和 <code>Number.NEGATIVE_INFINITY</code>。</p>\n<p>Number 类型仅有一个具有多个表现形式的值：<code>-0</code> 和 <code>+0</code> 都表示 0（其中 0 是 <code>+0</code> 的别名）。实际上，这两者之间几乎没有区别；例如，<code>+0 === -0</code> 是 <code>true</code>。然而，当你除以 0 的时候，你会注意到区别：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">42</span> / +<span class=\"number\">0</span>); <span class=\"comment\">// Infinity</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"number\">42</span> / -<span class=\"number\">0</span>); <span class=\"comment\">// -Infinity</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>NaN</code>（“Not a Number”）是一个特殊种类的数字值，当算术运算的结果不能表示为数字时，通常会遇到它。它也是 JavaScript 中唯一不等于自身的值。</p>\n<p>虽然 number 在概念上是一个“数学的值”，并且总是隐式的编码为浮点类型，但是 JavaScript 提供了位运算符。当应用位运算符时，number 首先转换为 32 位整数。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>备注：尽管位运算符可以使用位掩码来表示单个数字中的几个布尔值，但这通常不是最佳实践。JavaScript 提供了表示一组布尔值的其他方法（如布尔数组，或将布尔值赋值给具名属性的对象）。位掩码也往往让代码更难阅读、理解和维护。</p>\n<p>在非常受限的环境中使用此类技术可能很必要，例如在试图应对本地存储的限制时，或在极端情况下（例如当网络上的每个位计数时）。只有当它是最后的优化大小的措施时，才应考虑这项技术。</p></blockquote>\n<h3 id=\"BigInt-类型\"><a href=\"#BigInt-类型\" class=\"headerlink\" title=\"BigInt 类型\"></a>BigInt 类型</h3><p>BigInt 类型是 JavaScript 中的数字原始类型，它可以表示任意大小的整数。使用 BigInt，你可以安全地存储和操作巨大的整数，即便是超过 Number 的安全整数限制（<code>Number.MAX_SAFE_INTEGER</code>）。</p>\n<p>BigInt 通过在整数末尾添加 <code>n</code> 或调用 <code>BigInt()</code> 函数创建。</p>\n<p>本例演示了递增 <code>Number.MAX_SAFE_INTEGER</code> 会返回预期的结果：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BigInt</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"title class_\">BigInt</span>(<span class=\"title class_\">Number</span>.<span class=\"property\">MAX_SAFE_INTEGER</span>); <span class=\"comment\">// 9007199254740991n</span></span><br><span class=\"line\">x + <span class=\"number\">1n</span> === x + <span class=\"number\">2n</span>; <span class=\"comment\">// false，因为 9007199254740992n 和 9007199254740993n 不相等</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Number</span></span><br><span class=\"line\"><span class=\"title class_\">Number</span>.<span class=\"property\">MAX_SAFE_INTEGER</span> + <span class=\"number\">1</span> === <span class=\"title class_\">Number</span>.<span class=\"property\">MAX_SAFE_INTEGER</span> + <span class=\"number\">2</span>; <span class=\"comment\">// true，因为都等于 9007199254740992</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>你可以使用大多数运算符处理 BigInt，包括 <code>+</code>、<code>*</code>、<code>-</code>、<code>**</code> 和 <code>%</code>——唯一被禁止的是 <code>&gt;&gt;&gt;</code>。BigInt 并不是严格等于有着相同数学值的 Number，而是非严格相等。</p>\n<p>BigInt 值和 number 值相比，不总是更精确，也不总是更不精确，因为 <strong>BigInt 不能表示小数，但能更精确地表示大整数</strong>。<strong>这两种类型都不能相互替代</strong>。如果在算术表达式中将 BigInt 值和常规 number 值混合，或者它们相互隐式转换，则抛出 TypeError。</p>\n<h3 id=\"String-类型\"><a href=\"#String-类型\" class=\"headerlink\" title=\"String 类型\"></a>String 类型</h3><p>String 类型表示文本数据并编码为 UTF-16 码元的 16 位无符号整数值序列。字符串中的每个元素在字符串中占据一个位置。第一个元素的索引为 <code>0</code>，下一个的索引为 <code>1</code>，依此类推。字符串的长度是其中的 UTF-16 码元的数量，这可能与 Unicode 字符的实际数量不符；更多细节参见 String 参考页面。</p>\n<p>JavaScript 字符串是不可变的。这意味着一旦字符串被创建，就不可能修改它。字符串方法会基于当前字符串的内容创建一个新的字符串——例如：</p>\n<ul>\n<li>使用 <code>substring()</code> 获取原始字符串的子字符串。</li>\n<li>使用串联运算符（<code>+</code>）或 <code>concat()</code> 将两个字符串串联。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意代码中的“字符串类型”！</p>\n<p>使用字符串来表示复杂的数据可能很诱人。这样做会带来短期的好处：</p>\n<ul>\n<li>通过字符串拼接构造复杂的字符串很容易。</li>\n<li>字符串容易调试（你看到的打印内容始终是字符串中的内容）。</li>\n<li>字符串是许多 API 的常见标准（input 字段、local storage 中的值，以及 fetch() 使用 Response.text() 时的响应，等等）而且这些 API 可能只能与字符串一同使用。</li>\n</ul>\n<p>按照常规，用字符串表示任何数据结构是可能的。但这并不总是一个好主意。例如，使用一个分隔符，可以模拟一个列表（然而 JavaScript 数组更适合）。不幸的是，当分隔符是某个“列表”元素时，列表就遭到破坏。这时可以选择转义字符，等等。所有这些都需要约定，并造成不必要的维护负担。</p>\n<p>表示文本数据时推荐使用字符串。当需要表示复杂的数据时，使用字符串解析并使用适当的抽象。</p></blockquote>\n<h3 id=\"Symbol-类型\"><a href=\"#Symbol-类型\" class=\"headerlink\" title=\"Symbol 类型\"></a>Symbol 类型</h3><p>Symbol 是一种唯一并且不可变的原始值，并且可以用作对象属性的键（如下）。在某些程序语言中，Symbol 也被称作“原子”。symbol 的目的是创建唯一的属性键，保证不会与其他代码中的键产生冲突。</p>\n<h2 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h2><p>在计算机科学中，<strong>对象</strong>是指内存中的值，这块内存可能被标识符引用。在 JavaScript 中，<strong>对象是唯一可变的值</strong>。事实上，函数也是具有可调用这个额外能力的对象。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>在 JavaScript 中，对象可以被看作是一个属性的集合。用对象字面量语法会初始化一组有限的属性；然后，可以添加和移除属性。对象属性等价于键值对。属性键要么是字符串，要么是 symbol。当其他类型（如数字）用于索引对象时，值会隐式地转化为字符串。属性值可以是任何类型的值，包括其他对象，从而可以构建复杂的数据结构。</p>\n<p>有两种类型的对象属性：数据属性和访问器属性。每个属性都有对应的特性。每个特性由 JavaScript 引擎进行内部访问，但是你可以通过 Object.defineProperty() 设置它们，或通过 Object.getOwnPropertyDescriptor() 读取它们。你可以在 Object.defineProperty() 页面阅读更多有关各种细微差别的信息。</p>\n<h4 id=\"数据属性\"><a href=\"#数据属性\" class=\"headerlink\" title=\"数据属性\"></a>数据属性</h4><p>数据属性将键与值相关联。它可以由以下特性描述：</p>\n<p><strong>value</strong><br>通过属性的 get 访问获取值。可以是任意的 JavaScript 值。</p>\n<p><strong>writable</strong><br>布尔值，表示属性是否可以通过赋值进行修改。</p>\n<p><strong>enumerable</strong><br>布尔值，表示属性是否可以通过 <code>for...in</code> 循环进行枚举。另请参阅属性的可枚举性和所有权，以了解枚举性如何与其他函数和语法交互。</p>\n<p><strong>configurable</strong><br>布尔值，表示属性是否可以删除，是否可以更改为访问器属性，以及是否可以更改其特性。</p>\n<h4 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h4><p>将键与两个访问器函数（get 和 set）相关联，以获取或者存储值。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>备注</strong>：重要的是，意识到它是访问器属性——而不是访问器方法。我们可以将函数作为值给一个 JavaScript 对象提供近似于类的访问器——但这并不能使该对象成为类。</p></blockquote>\n<p>访问器属性有以下特性：</p>\n<p><strong>get</strong><br>当执行值的 get 访问时，使用一个空的参数列表调用函数获取属性值。参见 getter。可能是 <code>undefined</code>。</p>\n<p><strong>set</strong><br>使用包含赋予的值的参数调用函数。每当尝试更改指定属性时执行。参见 setter。可能是 <code>undefined</code>。</p>\n<p><strong>enumerable</strong><br>布尔值，表示属性是否可以通过 <code>for...in</code> 循环进行枚举。另请参阅属性的可枚举性和所有权，以了解枚举性如何与其他函数和语法交互。</p>\n<p><strong>configurable</strong><br>布尔值，表示属性是否可以删除，是否可以更改为访问器属性，以及是否可以更改其特性。</p>\n<p>对象的原型指向另一个对象或者 null——从概念上讲，它是对象的隐藏属性，通常表示为 <code>[[Prototype]]</code>。对象的 <code>[[Prototype]]</code> 的属性也可以在对象自身上访问。</p>\n<p>对象是临时的键值对，因此经常被用作 map。不过，这可能存在人体工程学、安全性和性能方面的问题。请使用 Map 存储任意的数据。Map 参考对使用普通对象和使用 map 存储键值之间的利弊进行了更详细的讨论。</p>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p>当表示日期时，最好的选择是使用 JavaScript 中内置的 Date 工具类。</p>\n<h3 id=\"索引类集合：数组和类型化数组\"><a href=\"#索引类集合：数组和类型化数组\" class=\"headerlink\" title=\"索引类集合：数组和类型化数组\"></a>索引类集合：数组和类型化数组</h3><p>数组是整数键的属性和 length 属性之间有着特殊关系的常规对象。</p>\n<p>此外，数组继承了 Array.prototype 的一组操作数组的便捷方法。例如，indexOf()（搜索数组中的一个值）或 push()（向数组追加一个元素），等等。这使得数组成为表示有序列表的理想选择。</p>\n<p>类型化数组表示底层二进制缓冲区的类数组视图，并且提供了与数组相对应的类似语义的方法。“类型化数组”是一系列数据结构的总话术语，包括 Int8Array、Float32Array 等等。获取更多细节，请查看类型化数组页。类型化数组通常与 ArrayBuffer 和 DataView 一起使用。</p>\n<h3 id=\"带键的集合：Map、Set、WeakMap、WeakSet\"><a href=\"#带键的集合：Map、Set、WeakMap、WeakSet\" class=\"headerlink\" title=\"带键的集合：Map、Set、WeakMap、WeakSet\"></a>带键的集合：Map、Set、WeakMap、WeakSet</h3><p>这些数据结构把对象的引用当作键。Set 和 WeakSet 表示唯一值的集合，而 Map 和 WeakMap 表示键值相关联的集合。</p>\n<p>你也可以自己实现 Map 和 Set。然而，因为对象不能比较（例如，在 &lt;“小于”的意义上），另一方面，引擎也没有暴露对象的散列函数，因此查找性能必定是线性的。它们的原生实现（包括 WeakMap）有着近似对数到常数时间的查找性能。</p>\n<p>通常，要将数据绑定到 DOM 节点，可以直接在对象上设置属性，或使用 data-* 属性。这样做的缺点是，在同一上下文中运行的任何脚本都可以使用这些数据。而 Map 和 WeakMap 则可以轻松地将数据隐蔽地绑定到对象上。</p>\n<p>WeakMap 和 WeakSet 只允许将可垃圾回收的值作为键，这些键要么是对象，要么是未注册的 symbol，即使键仍在集合中，也可能被回收。它们专门用于优化内存使用。</p>\n<h3 id=\"结构化数据：JSON\"><a href=\"#结构化数据：JSON\" class=\"headerlink\" title=\"结构化数据：JSON\"></a>结构化数据：JSON</h3><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，来源于 JavaScript，同时也被多种语言所使用。JSON 构建了通用的数据结构，可以在不同环境之间传输，甚至可以跨语言传输。更多细节，请参见 JSON。</p>\n<h3 id=\"标准库中的更多对象\"><a href=\"#标准库中的更多对象\" class=\"headerlink\" title=\"标准库中的更多对象\"></a>标准库中的更多对象</h3><p>JavaScript 有一个内置对象的标准库。请阅读参考了解有关内置对象的更多信息。</p>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><p>如上所述，JavaScript 是一门弱类型语言。这意味着你可以经常使用与预期类型不同的类型的值，JavaScript 语言将为你把它转换为正确的类型。为此，JavaScript 定义了一些强制转换规则。</p>\n<h3 id=\"原始值强制转换\"><a href=\"#原始值强制转换\" class=\"headerlink\" title=\"原始值强制转换\"></a>原始值强制转换</h3><p>原始值强制转换过程用于得到期望的原始值，但对实际的类型应该是什么并没有强烈的偏好。通常情况下可以接受 string、number 或 BigInt。例如：</p>\n<p>Date() 构造函数，当它收到一个不是 Date 实例的参数时——字符串表示日期字符串，而 number 表示时间戳。</p>\n<ul>\n<li><code>+</code> 运算符——如果某个操作数是字符串，执行字符串串联；否则，执行数字相加。</li>\n<li>== 运算符——如果某个操作数是原始值，而另一个操作数是对象（object），则该对象将转换为没有首选类型的原始值。</li>\n<li>如果值已经是原始值，则此操作不会进行任何转换。对象将依次调用它的 <code>[Symbol.toPrimitive]()</code>（将 default 作为 hint 值）、<code>valueOf()</code> 和 <code>toString()</code> 方法，将其转换为原始值。注意，原始值转换会在 <code>toString()</code> 方法之前调用 <code>valueOf()</code> 方法，这与 number 强制转换的行为相似，但与字符串强制转换不同。</li>\n</ul>\n<p><code>[Symbol.toPrimitive]()</code> 方法，如果存在，则必须返回原始值——返回对象，会导致 TypeError。对于 <code>valueOf()</code> 和 <code>toString()</code>，如果其中一个返回对象，则忽略其返回值，从而使用另一个的返回值；如果两者都不存在，或者两者都没有返回原始值，则抛出 TypeError。例如，在下面的代码中：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>({} + []); <span class=\"comment\">// \"[object Object]\"</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>{}</code> 和 <code>[]</code> 都没有 <code>[Symbol.toPrimitive]()</code> 方法。<code>{}</code> 和 <code>[]</code> 都从 <code>Object.prototype.valueOf</code> 继承 <code>valueOf()</code>，其返回对象自身。因为返回值是对象，所以它被忽略。因此，调用 <code>toString()</code> 方法。<code>{}.toString()</code> 返回 <code>\"[object Object]\"</code>，而 <code>[].toString()</code> 返回 <code>\"\"</code>，因此这个结果是它们的串联：<code>\"[object Object]\"</code>。</p>\n<p>在强制转换为任意的原始类型时，<code>[Symbol.toPrimitive]()</code> 方法总是优先调用。原始值强制转换的行为通常与 number 强制转换类似，因为优先调用了 <code>valueOf()</code>；然而，有着自定义 <code>[Symbol.toPrimitive]()</code> 方法的对象可以选择返回任意的原始值。Date 和 Symbol 对象是唯一重写 <code>[Symbol.toPrimitive]()</code> 方法的对象。<code>Date.prototype[Symbol.toPrimitive]()</code> 将 “string” 视为 “default” hint，而 <code>Symbol.prototype[Symbol.toPrimitive]()</code> 忽略 hint 并始终返回一个 symbol。</p>\n<h3 id=\"数字类型强制转换\"><a href=\"#数字类型强制转换\" class=\"headerlink\" title=\"数字类型强制转换\"></a>数字类型强制转换</h3><p>有两种数字类型：Number 和 BigInt。有时候，JavaScript 语言期望使用 number 或 BigInt（例如 <code>Array.prototype.slice()</code>，其中索引必须是 number）；其他时候，它可能容忍并且根据操作数的类型执行不同的运算。有关不允许从其他类型隐式转换的严格强制转换过程，请参阅 number 强制转换和 BigInt 强制转换。</p>\n<p>数字类型强制转换与 number 强制转换几乎相同，只是 BigInt 会按原样返回，而不是引起 TypeError。强制数字类型转换用于所有算术运算，因为它们重载了 number 和 BigInt 类型。唯一例外的是一元加，它总是实施 number 强制转换。</p>\n<h3 id=\"其他类型强制转换\"><a href=\"#其他类型强制转换\" class=\"headerlink\" title=\"其他类型强制转换\"></a>其他类型强制转换</h3><p>除了 Null、Undefined 以及 Symbol 类型以外，所有的数据类型都有它们各自的强制转换过程。更多细节，请参见字符串强制转换、布尔值强制转换以及对象强制转换。</p>\n<p>你可能已经注意到，有三种不同的路径可以将对象转换为原始值：</p>\n<ul>\n<li>原始值强制转换：<code>[Symbol.toPrimitive](\"default\")</code> → <code>valueOf()</code> → <code>toString()</code></li>\n<li>数字类型强制转换、number 强制转换、BigInt 强制转换：<code>[Symbol.toPrimitive](\"number\")</code> → <code>valueOf()</code> → <code>toString()</code></li>\n<li>字符串强制转换：<code>[Symbol.toPrimitive](\"string\")</code> → <code>toString()</code> → <code>valueOf()</code></li>\n</ul>\n<p>在所有情况下，<code>[Symbol.toPrimitive]()</code> 如果存在，必须可调用并返回原始值，而如果 <code>valueOf</code> 或 <code>toString</code> 不可调用或返回对象，它们将被忽略。在过程结束时，<strong>如果成功，结果保证是原始值</strong>。然后，由此产生的原始值会根据上下文进一步的进行强制类型转换。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文目前还不是很完善，只是将<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\">MDN文档：JavaScript 数据类型和数据结构</a>中的内容进行了格式整理，相关文章还没有引入，后续会继续完善。</p>\n<p>参考文献：</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures\">MDN文档：JavaScript 数据类型和数据结构</a></li>\n</ul>\n","text":"JavaScript中的数据类型和数据结构数据类型和数据结构是编程中的基本概念，也是几乎掌握任何一门语言都要最先学习的，它的重要性与原理也常常被忽视。 编程语言...","permalink":"/post/js-data-structures","photos":[],"count_time":{"symbolsCount":"9k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":21,"path":"api/categories/前端.json"}],"tags":[{"name":"技术","slug":"技术","count":19,"path":"api/tags/技术.json"},{"name":"前端","slug":"前端","count":21,"path":"api/tags/前端.json"},{"name":"笔记","slug":"笔记","count":15,"path":"api/tags/笔记.json"},{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/tags/JavaScript.json"},{"name":"数据类型","slug":"数据类型","count":1,"path":"api/tags/数据类型.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaScript%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">JavaScript中的数据类型和数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%B1%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">动态类型和弱类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%A7%8B%E5%80%BC\"><span class=\"toc-text\">原始值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Null-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Null 类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Undefined-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Undefined 类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Boolean-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Boolean 类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Number-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Number 类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#BigInt-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">BigInt 类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#String-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">String 类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Symbol-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">Symbol 类型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Object\"><span class=\"toc-text\">Object</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">属性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">数据属性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">访问器属性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Date\"><span class=\"toc-text\">Date</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%B1%BB%E9%9B%86%E5%90%88%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%8C%96%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">索引类集合：数组和类型化数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%A6%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%9AMap%E3%80%81Set%E3%80%81WeakMap%E3%80%81WeakSet\"><span class=\"toc-text\">带键的集合：Map、Set、WeakMap、WeakSet</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%EF%BC%9AJSON\"><span class=\"toc-text\">结构化数据：JSON</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E6%9B%B4%E5%A4%9A%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">标准库中的更多对象</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">强制类型转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">原始值强制转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">数字类型强制转换</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">其他类型强制转换</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol>","author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"力扣周记-2","uid":"4b9b17caa7847eb05c04c2c412ad271a","slug":"leetcode-weekly-journal-2","date":"2025-09-13T10:46:15.000Z","updated":"2025-10-02T02:28:07.567Z","comments":true,"path":"api/articles/leetcode-weekly-journal-2.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-leetcode.png","text":"力扣周记-22025.9.15 - 2025.9.21 一、字母异位词分组(49)标签 哈希表 题目描述给你一个字符串数组，请你将 字母异位词 组合在一起。可以...","permalink":"/post/leetcode-weekly-journal-2","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"算法题","slug":"算法题","count":4,"path":"api/categories/算法题.json"}],"tags":[{"name":"笔记","slug":"笔记","count":15,"path":"api/tags/笔记.json"},{"name":"力扣","slug":"力扣","count":4,"path":"api/tags/力扣.json"},{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JavaScript中的相等比较和相同","uid":"fb6d1bb37eb27e9281171cb6130d8351","slug":"js-equality-comparisons-and-sameness","date":"2025-08-26T10:02:07.000Z","updated":"2025-09-13T11:24:51.313Z","comments":true,"path":"api/articles/js-equality-comparisons-and-sameness.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-js.png","text":"JavaScript中的相等比较和相同 曾在JS的社区中看到这样一张图以及其制作的一些梗图，奇奇怪怪的相等性比较让人摸不着头脑，似乎是JS“灵活”、“不严谨”的...","permalink":"/post/js-equality-comparisons-and-sameness","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"前端","slug":"前端","count":21,"path":"api/categories/前端.json"}],"tags":[{"name":"技术","slug":"技术","count":19,"path":"api/tags/技术.json"},{"name":"前端","slug":"前端","count":21,"path":"api/tags/前端.json"},{"name":"笔记","slug":"笔记","count":15,"path":"api/tags/笔记.json"},{"name":"JavaScript","slug":"JavaScript","count":9,"path":"api/tags/JavaScript.json"},{"name":"相等性","slug":"相等性","count":1,"path":"api/tags/相等性.json"},{"name":"Object.is","slug":"Object-is","count":1,"path":"api/tags/Object-is.json"}],"author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}