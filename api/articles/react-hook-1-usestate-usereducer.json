{"title":"React钩子函数-1-useState和useReducer","uid":"2c9152db5ab3b447eb6957f90810b68a","slug":"react-hook-1-usestate-usereducer","date":"2025-07-30T02:52:16.000Z","updated":"2025-08-26T11:06:07.762Z","comments":true,"path":"api/articles/react-hook-1-usestate-usereducer.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-react.png","content":"<h1 id=\"React钩子函数-1-useState和useReducer\"><a href=\"#React钩子函数-1-useState和useReducer\" class=\"headerlink\" title=\"React钩子函数-1-useState和useReducer\"></a>React钩子函数-1-useState和useReducer</h1><h2 id=\"一、背景与概述\"><a href=\"#一、背景与概述\" class=\"headerlink\" title=\"一、背景与概述\"></a>一、背景与概述</h2><p>这两个钩子函数归纳为 <strong>State Hook</strong>。</p>\n<p>状态帮助组件 “记住”用户输入的信息。例如，一个表单组件可以使用状态存储输入值，而一个图像库组件可以使用状态存储所选的图像索引。</p>\n<ul>\n<li>使用 <code>useState</code> 声明可以直接更新的状态变量。</li>\n<li>使用 <code>useReducer</code> 在 <code>reducer</code> 函数 中声明带有更新逻辑的 <code>state</code> 变量。</li>\n</ul>\n<p>在正式学习前，你有必要了解 React 中的 <strong>渲染和提交</strong> 这一基本但重要的概念。</p>\n<h3 id=\"渲染和提交\"><a href=\"#渲染和提交\" class=\"headerlink\" title=\"渲染和提交\"></a>渲染和提交</h3><p>组件显示到屏幕之前，其必须被 React 渲染。</p>\n<p>想象一下，你的组件是厨房里的厨师，把食材烹制成美味的菜肴。在这种场景下，React 就是一名服务员，他会帮客户们下单并为他们送来所点的菜品。这种请求和提供 UI 的过程总共包括三个步骤：</p>\n<ol>\n<li><strong>触发</strong> 一次渲染（把客人的点单分发到厨房）</li>\n<li><strong>渲染</strong> 组件（在厨房准备订单）</li>\n<li><strong>提交</strong> 到 DOM（将菜品放在桌子上）<br><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/react-hook-1-usestate-usereducer/1.png\" alt=\"请求和提供UI\"></li>\n</ol>\n<h4 id=\"步骤-1-触发一次渲染\"><a href=\"#步骤-1-触发一次渲染\" class=\"headerlink\" title=\"步骤 1: 触发一次渲染\"></a>步骤 1: 触发一次渲染</h4><p>有两种原因会导致组件的渲染:</p>\n<ol>\n<li>组件的 <strong>初次渲染</strong>。</li>\n<li>组件（或者其祖先之一）的 <strong>状态发生了改变</strong>。</li>\n</ol>\n<h5 id=\"初次渲染\"><a href=\"#初次渲染\" class=\"headerlink\" title=\"初次渲染\"></a>初次渲染</h5><p>当应用启动时，会触发初次渲染。框架和沙箱有时会隐藏这部分代码，但它是通过调用 <code>createRoot</code> 方法并传入目标 DOM 节点，然后用你的组件调用 <code>render</code> 函数完成的：</p>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">Image</span> <span class=\"keyword\">from</span> <span class=\"string\">'./Image.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> { createRoot } <span class=\"keyword\">from</span> <span class=\"string\">'react-dom/client'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> root = <span class=\"title function_\">createRoot</span>(<span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">'root'</span>))</span><br><span class=\"line\">root.<span class=\"title function_\">render</span>(<span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">Image</span> /&gt;</span></span>);</span><br></pre></td></tr></tbody></table></figure>\n\n<h5 id=\"状态更新时重新渲染\"><a href=\"#状态更新时重新渲染\" class=\"headerlink\" title=\"状态更新时重新渲染\"></a>状态更新时重新渲染</h5><p>一旦组件被初次渲染，你就可以通过使用 <code>set</code> 函数 更新其状态来触发之后的渲染。更新组件的状态会自动将一次渲染送入队列。（你可以把这种情况想象成餐厅客人在第一次下单之后又点了茶、点心和各种东西，具体取决于他们的胃口。）<br><img src=\"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/react-hook-1-usestate-usereducer/2.png\" alt=\"状态更新时重新渲染\"></p>\n<h4 id=\"步骤-2-React-渲染你的组件\"><a href=\"#步骤-2-React-渲染你的组件\" class=\"headerlink\" title=\"步骤 2: React 渲染你的组件\"></a>步骤 2: React 渲染你的组件</h4><p>在你触发渲染后，React 会调用你的组件来确定要在屏幕上显示的内容。<strong>“渲染中” 即 React 在调用你的组件。</strong></p>\n<ul>\n<li>在进行初次渲染时, React 会调用根组件。</li>\n<li>对于后续的渲染, React 会调用内部状态更新触发了渲染的函数组件。</li>\n</ul>\n<p>这个过程是<strong>递归</strong>的：如果更新后的组件会返回某个另外的组件，那么 React 接下来就会渲染那个组件，而如果那个组件又返回了某个组件，那么 React 接下来就会渲染那个组件，以此类推。这个过程会持续下去，直到没有更多的嵌套组件并且 React 确切知道哪些东西应该显示到屏幕上为止。</p>\n<p>注意：渲染必须始终是一次 <strong>纯计算</strong></p>\n<ul>\n<li><strong>输入相同，输出相同。</strong> 给定相同的输入，组件应始终返回相同的 JSX。（当有人点了西红柿沙拉时，他们不应该收到洋葱沙拉！）</li>\n<li><strong>只做它自己的事情。</strong> 它不应更改任何存在于渲染之前的对象或变量。（一个订单不应更改其他任何人的订单。）</li>\n</ul>\n<p>否则，随着代码库复杂性的增加，你可能会遇到令人困惑的错误和不可预测的行为。在 “严格模式” 下开发时，React 会调用每个组件的函数两次，这可以帮助发现由不纯函数引起的错误。</p>\n<h4 id=\"步骤-3-React-把更改提交到-DOM-上\"><a href=\"#步骤-3-React-把更改提交到-DOM-上\" class=\"headerlink\" title=\"步骤 3: React 把更改提交到 DOM 上\"></a>步骤 3: React 把更改提交到 DOM 上</h4><p>在渲染（调用）你的组件之后，React 将会修改 DOM。</p>\n<ul>\n<li><strong>对于初次渲染</strong>，React 会使用 <code>appendChild()</code> DOM API 将其创建的所有 DOM 节点放在屏幕上。</li>\n<li><strong>对于重渲染</strong>，React 将应用最少的必要操作（在渲染时计算！），以使得 DOM 与最新的渲染输出相互匹配。</li>\n</ul>\n<p><strong>React 仅在渲染之间存在差异时才会更改 DOM 节点。</strong> 例如，有一个组件，它每秒使用从父组件传递下来的不同属性重新渲染一次。注意，你可以添加一些文本到 <code>&lt;input&gt;</code> 标签，更新它的 value，但是文本不会在组件重渲染时消失。</p>\n<h4 id=\"尾声：浏览器绘制\"><a href=\"#尾声：浏览器绘制\" class=\"headerlink\" title=\"尾声：浏览器绘制\"></a>尾声：浏览器绘制</h4><p>在渲染完成并且 React 更新 DOM 之后，浏览器就会重新绘制屏幕。尽管这个过程被称为“浏览器渲染”（“browser rendering”），但我们还是将它称为“绘制”（“painting”），以避免在这些文档的其余部分中出现混淆。</p>\n<h2 id=\"二、useState\"><a href=\"#二、useState\" class=\"headerlink\" title=\"二、useState\"></a>二、useState</h2><h3 id=\"引入-useState\"><a href=\"#引入-useState\" class=\"headerlink\" title=\"引入 useState\"></a>引入 useState</h3><p><strong>useState</strong> 是一个 React Hook，它允许你向组件添加一个状态变量<code>(state)</code>。</p>\n<p>组件通常需要根据交互更改屏幕上显示的内容。输入表单应该更新输入字段，单击轮播图上的“下一个”应该更改显示的图片，单击“购买”应该将商品放入购物车。组件需要“记住”某些东西：当前输入值、当前图片、购物车。在 React 中，这种组件特有的记忆被称为 <code>state</code>。</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 需要引入 state 的情景</span></span><br><span class=\"line\"><span class=\"comment\">// 如果不使用 state 不能正常更新变量</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Foo</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">let</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    index = index + <span class=\"number\">1</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{handleClick}</span>&gt;</span>Next<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>{index}<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>handleClick()</code> 事件处理函数正在更新局部变量 <code>index</code>。但存在两个原因使得变化不可见：</p>\n<ol>\n<li><strong>局部变量无法在多次渲染中持久保存</strong>。 当 React 再次渲染这个组件时，它会从头开始渲染——不会考虑之前对局部变量的任何更改。</li>\n<li><strong>更改局部变量不会触发渲染</strong>。 React 没有意识到它需要使用新数据再次渲染组件。</li>\n</ol>\n<p>要使用新数据更新组件，需要做两件事：</p>\n<ol>\n<li><strong>保留</strong> 渲染之间的数据。</li>\n<li><strong>触发</strong> React 使用新数据渲染组件（重新渲染）。</li>\n</ol>\n<p>useState Hook 提供了这两个功能：</p>\n<ol>\n<li><strong>State 变量</strong> 用于保存渲染间的数据。</li>\n<li><strong>State setter 函数</strong> 更新变量并触发 React 再次渲染组件。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 useState Hook</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, { useState } <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> [state, setState] = <span class=\"title function_\">useState</span>(initialState);</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"useState-initialState\"><a href=\"#useState-initialState\" class=\"headerlink\" title=\"useState(initialState)\"></a>useState(initialState)</h4><p>在组件的顶层调用 <code>useState</code> 来声明一个 <strong>状态变量</strong>。<br>按照惯例使用 <strong>数组解构</strong> 来命名状态变量，例如 <code>[something, setSomething]</code>。</p>\n<p><strong>参数：</strong></p>\n<ul>\n<li><code>initialState</code>：你希望 <code>state</code> 初始化的值。它可以是任何类型的值，但对于函数有特殊的行为。在初始渲染后，此参数将被忽略。<br>如果传递函数作为 <code>initialState</code>，则它将被视为 <strong>初始化函数</strong>。它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其<strong>返回值</strong>存储为初始状态。</li>\n</ul>\n<p><strong>返回：</strong></p>\n<p>useState 返回一个由两个值组成的数组：</p>\n<ol>\n<li>当前的 state。在首次渲染时，它将与你传递的 initialState 相匹配。</li>\n<li>set 函数，它可以让你将 state 更新为不同的值并触发重新渲染。</li>\n</ol>\n<p><strong>注意事项：</strong></p>\n<ul>\n<li>useState 是一个 Hook，因此你只能在<strong>组件的顶层</strong>或自己的 Hook 中调用它。你不能在循环或条件语句中调用它。如果你需要这样做，请提取一个新组件并将状态移入其中。</li>\n<li>在<strong>严格模式</strong>中，React 将<strong>两次调用初始化函数</strong>，以帮你找到意外的不纯性。这只是开发时的行为，不影响生产。如果你的初始化函数是纯函数（本该是这样），就不应影响该行为。其中一个调用的结果将被忽略。</li>\n</ul>\n<h4 id=\"set-函数，例如-setSomething-nextState\"><a href=\"#set-函数，例如-setSomething-nextState\" class=\"headerlink\" title=\"set 函数，例如 setSomething(nextState)\"></a>set 函数，例如 setSomething(nextState)</h4><p><code>useState</code> 返回的 <code>set</code> 函数允许你将 <code>state</code> 更新为不同的值并<strong>触发重新渲染</strong>。你可以直接传递新状态，也可以传递一个根据先前状态来计算新状态的函数。</p>\n<p><strong>参数：</strong></p>\n<ul>\n<li><code>nextState</code>：你想要 <code>state</code> 更新为的值。它可以是任何类型的值，但对于函数有特殊的行为。<ul>\n<li>如果你将函数作为 <code>nextState</code> 传递，它将被视为<strong>更新函数</strong>。它必须是<strong>纯函数</strong>，只接受待定的 <code>state</code> 作为其唯一参数，并应返回下一个状态。React 将把你的更新函数放入队列中并重新渲染组件。在下一次渲染期间，React 将通过把队列中所有更新函数应用于先前的状态来计算下一个状态。</li>\n</ul>\n</li>\n</ul>\n<p><strong>返回值：</strong></p>\n<p><code>set</code> 函数没有返回值。</p>\n<p><strong>注意事项：</strong></p>\n<ul>\n<li><code>set</code> 函数 <strong>仅更新下一次渲染的状态变量</strong>。如果在调用 set 函数后读取状态变量，则<strong>仍会得到在调用之前显示在屏幕上的旧值</strong>。</li>\n<li>如果你提供的新值与当前 state <strong>相同</strong>（由 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\">Object.is</a> 比较确定），React 将<strong>跳过重新渲染该组件及其子组件</strong>。这是一种优化。虽然在某些情况下 React 仍然需要在跳过子组件之前调用你的组件，但这不应影响你的代码。</li>\n<li>React 会 <strong>批量处理状态更新</strong>。它会在所有 事件处理函数运行 并调用其 set 函数后更新屏幕。这可以防止在单个事件期间多次重新渲染。在某些罕见情况下，你需要强制 React 更早地更新屏幕，例如访问 DOM，你可以使用 flushSync。</li>\n<li><code>set</code> 函数具有<strong>稳定的标识</strong>，所以你经常会看到 <code>Effect</code> 的依赖数组中会省略它，即使包含它也不会导致 <code>Effect</code> 重新触发。如果 linter 允许你省略依赖项并且没有报错，那么你就可以安全地省略它。</li>\n<li>在渲染期间，只允许在当前渲染组件内部调用 <code>set</code> 函数。React 将丢弃其输出并立即尝试使用新状态重新渲染。这种方式很少需要，但你可以使用它来存储<strong>先前渲染中的信息</strong>。</li>\n<li>在<strong>严格模式</strong>中，React 将<strong>两次调用你的更新函数</strong>，以帮助你找到意外的不纯性。这只是开发时的行为，不影响生产。如果你的更新函数是<strong>纯函数</strong>（本该是这样），就不应影响该行为。其中一次调用的结果将被忽略。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 useState 对上例进行修改</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, { useState } <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [index, setIndex] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">setIndex</span>(index + <span class=\"number\">1</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></tbody></table></figure>\n\n<ol>\n<li>组件进行第一次渲染。 因为你将 <code>0</code> 作为 <code>index</code> 的初始值传递给 <code>useState</code>，它将返回 <code>[0, setIndex]</code>。 React 记住 <code>0</code> 是最新的 <code>state</code> 值。</li>\n<li>你更新了 <code>state</code>。当用户点击按钮时，它会调用 <code>setIndex(index + 1)</code>。 <code>index</code> 是 <code>0</code>，所以它是 <code>setIndex(1)</code>。这告诉 React 现在记住 <code>index</code> 是 <code>1</code> 并触发下一次渲染。</li>\n<li>组件进行第二次渲染。React 仍然看到 <code>useState(0)</code>，但是因为 React 记住 了你将 <code>index</code> 设置为了 <code>1</code>，它将返回 <code>[1, setIndex]</code>。以此类推！</li>\n</ol>\n<h3 id=\"state-的特性\"><a href=\"#state-的特性\" class=\"headerlink\" title=\"state 的特性\"></a>state 的特性</h3><p>你可以在一个组件中拥有任意多个、多种类型的 <code>state</code> 变量。</p>\n<h4 id=\"State-是隔离且私有的\"><a href=\"#State-是隔离且私有的\" class=\"headerlink\" title=\"State 是隔离且私有的\"></a>State 是隔离且私有的</h4><p>State 是屏幕上组件实例内部的状态。换句话说，<strong>如果你渲染同一个组件两次，每个副本都会有完全隔离的 state</strong>！改变其中一个不会影响另一个。</p>\n<p>这就是 <code>state</code> 与声明在模块顶部的普通变量不同的原因。 <code>State</code> 不依赖于特定的函数调用或在代码中的位置，它的作用域“只限于”屏幕上的某块特定区域。</p>\n<p><code>state</code> 完全私有于声明它的组件。父组件无法更改它。这使你可以向任何组件添加或删除 <code>state</code>，而不会影响其他组件。</p>\n<p>而如果你希望多个拥有相同组件的副本共享 <code>state</code>，你可以将 <code>state</code> 提升到它们的共同父组件中，即将相关 <code>state</code> 从这两个组件上移除，并把 <code>state</code> 放到它们的公共父级，再通过 <code>props</code> 将 <code>state</code> 传递给这两个组件。这被称为“<strong>状态提升</strong>”。</p>\n<p>对于每个独特的状态，都应该存在且只存在于一个指定的组件中作为 <code>state</code>。这一原则也被称为拥有 “<strong>可信单一数据源</strong>”。它并不意味着所有状态都存在一个地方——对每个状态来说，都需要一个特定的组件来保存这些状态信息。你应该 <strong>将状态提升</strong> 到公共父级，或 <strong>将状态传递</strong> 到需要它的子级中，而不是在组件之间复制共享的状态。</p>\n<h4 id=\"state-如同一张快照\"><a href=\"#state-如同一张快照\" class=\"headerlink\" title=\"state 如同一张快照\"></a>state 如同一张快照</h4><p>也许 <code>state</code> 变量看起来和一般的可读写的 JavaScript 变量类似。但 <code>state</code> 在其表现出的特性上更像是一张快照。设置它不会更改你已有的 <code>state</code> 变量，但会触发重新渲染。</p>\n<p>设置 <code>state</code> 会触发渲染。你可能会认为你的用户界面会直接对点击之类的用户输入做出响应并发生变化。在 React 中，它的工作方式与这种思维模型略有不同。在上一页中，你看到了来自 React 的设置 <code>state</code> 请求重新渲染。这意味着要使界面对输入做出反应，你需要设置其 <code>state</code>。</p>\n<p>“正在渲染” 就意味着 React 正在调用你的组件——一个函数。你从该函数返回的 JSX 就像是在某个时间点上 UI 的快照。它的 <code>props</code>、事件处理函数和内部变量都是 根据当前渲染时的 <code>state</code> 被计算出来的。</p>\n<p>与照片或电影画面不同，你返回的 UI “快照”是<strong>可交互</strong>的。它其中包括类似事件处理函数的逻辑，这些逻辑用于指定如何对输入作出响应。React 随后会更新屏幕来匹配这张快照，并绑定事件处理函数。因此，按下按钮就会触发你 JSX 中的点击事件处理函数。</p>\n<p>当 React 重新渲染一个组件时：</p>\n<ol>\n<li>React 会再次调用你的函数</li>\n<li>函数会返回新的 JSX 快照</li>\n<li>React 会更新界面以匹配返回的快照</li>\n</ol>\n<p>一个 state 变量的值永远不会在一次渲染的内部发生变化，即使其事件处理函数的代码是异步的。它的值在 React 通过调用你的组件“获取 UI 的快照”时就被“固定”了。</p>\n<h4 id=\"state-的“批处理”\"><a href=\"#state-的“批处理”\" class=\"headerlink\" title=\"state 的“批处理”\"></a>state 的“批处理”</h4><p>React 会等到事件处理函数中的<strong>所有代码都运行完毕</strong>再处理你的 <code>state</code> 更新。</p>\n<p>这让你可以更新多个 <code>state</code> 变量——甚至来自多个组件的 <code>state</code> 变量——而不会触发太多的重新渲染。但这也意味着只有在你的事件处理函数及其中任何代码执行完成 之后，UI 才会更新。这种特性也就是<strong>批处理</strong>，它会使你的 React 应用运行得更快。它还会帮你避免处理只​​更新了一部分 state 变量的令人困惑的“半成品”渲染。</p>\n<p>React 不会跨多个需要刻意触发的事件（如点击）进行批处理——每次点击都是单独处理的。请放心，React 只会在一般来说安全的情况下才进行批处理。这可以确保，例如，如果第一次点击按钮会禁用表单，那么第二次点击就不会再次提交它。</p>\n<p>利用这一特性，可以实现在下次渲染前多次更新同一个 state，这将使用<strong>更新函数</strong>来实现，后文的“根据先前的 state 更新 state”部分将详细说明。</p>\n<h4 id=\"对-state-进行保留和重置\"><a href=\"#对-state-进行保留和重置\" class=\"headerlink\" title=\"对 state 进行保留和重置\"></a>对 state 进行保留和重置</h4><p><strong>各个组件的 state 是各自独立的</strong>。根据组件在 UI 树中的位置，React 可以跟踪哪些 <code>state</code> 属于哪个组件。你可以控制在重新渲染过程中何时对 <code>state</code> 进行保留和重置。</p>\n<p><strong>状态与渲染树中的位置相关</strong>。状态是由 React 保存的。React 通过组件在渲染树中的位置将它保存的每个状态与正确的组件关联起来。React 在移除一个组件时，也会销毁它的 <code>state</code>。只要一个组件还被渲染在 UI 树的相同位置，React 就会保留它的 <code>state</code>。如果它被移除，或者一个不同的组件被渲染在相同的位置，那么 React 就会丢掉它的 <code>state</code>。</p>\n<p><strong>相同位置的相同组件会使得 state 被保留下来</strong>。记住对 React 来说重要的是组件在 UI 树中的位置,而不是在 JSX 中的位置！React 不知道你的函数里是如何进行条件判断的，它只会“看到”你返回的树。</p>\n<p><strong>相同位置的不同组件会使 state 重置</strong>。并且，当你在相同位置渲染不同的组件时，组件的整个子树都会被重置。</p>\n<p>一般来说，如果你想在重新渲染时保留 <code>state</code>，几次渲染中的树形结构就应该相互“匹配”。结构不同就会导致 <code>state</code> 的销毁，因为 React 会在将一个组件从树中移除时销毁它的 <code>state</code>。<strong>永远要将组件定义在最上层并且不要把它们的定义嵌套起来</strong>。</p>\n<p><strong>在相同位置重置 state</strong>。有两个方法可以在它们相互切换时重置 <code>state</code>：</p>\n<ol>\n<li><strong>将组件渲染在不同的位置</strong>。这个解决方案在你只有少数几个独立的组件渲染在相同的位置时会很方便。</li>\n<li><strong>使用 <code>key</code> 赋予每个组件一个明确的身份</strong>。请记住 <code>key</code> 不是全局唯一的。它们只能指定<strong>父组件内部</strong>的顺序。使用 <code>key</code> 来重置 <code>state</code> 在处理表单时特别有用。</li>\n</ol>\n<h3 id=\"state-的构建原则\"><a href=\"#state-的构建原则\" class=\"headerlink\" title=\"state 的构建原则\"></a>state 的构建原则</h3><p>构建良好的 <code>state</code> 可以让组件变得易于修改和调试，而不会经常出错。以下是你在构建 <code>state</code> 时应该考虑的一些建议。</p>\n<ol>\n<li><strong>合并关联的 state</strong>。如果你总是<strong>同时</strong>更新两个或更多的 <code>state</code> 变量，请考虑将它们合并为一个单独的 <code>state</code> 变量。</li>\n<li><strong>避免互相矛盾的 state</strong>。当 <code>state</code> 结构中存在多个相互<strong>矛盾</strong>或“不一致”的 <code>state</code> 时，你就可能为此会留下隐患。应尽量避免这种情况。</li>\n<li><strong>避免冗余的 state</strong>。如果你能在渲染期间从组件的 <code>props</code> 或其现有的 <code>state</code> 变量中<strong>计算</strong>出一些信息，则不应将这些信息放入该组件的 <code>state</code> 中。</li>\n<li><strong>避免重复的 state</strong>。当同一数据在多个 <code>state</code> 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少<strong>重复</strong>。</li>\n<li><strong>避免深度嵌套的 state</strong>。深度分层的 <code>state</code> 更新起来不是很方便。如果可能的话，最好以<strong>扁平化</strong>方式构建 <code>state</code>。</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误示例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 矛盾的 state</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [isSending, setIsSending] = <span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [isSent, setIsSent] = <span class=\"title function_\">useState</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"comment\">//因为 isSending 和 isSent 不应同时为 true，所以最好用一个 status 变量来代替它们，这个 state 变量可以采取三种有效状态其中之一：'typing' (初始), 'sending', 和 'sent'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 冗余的 state</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [firstName, setFirstName] = <span class=\"title function_\">useState</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [lastName, setLastName] = <span class=\"title function_\">useState</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [fullName, setFullName] = <span class=\"title function_\">useState</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"comment\">// 这个表单有三个 state 变量：firstName、lastName 和 fullName。然而，fullName 是多余的。在渲染期间，你始终可以从 firstName 和 lastName 中计算出 fullName，因此需要把它从 state 中删除。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重复的 state</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [items, setItems] = <span class=\"title function_\">useState</span>(initialItems);</span><br><span class=\"line\"><span class=\"keyword\">const</span> [selectedItem, setSelectedItem] = <span class=\"title function_\">useState</span>(items[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"comment\">// selectedItem 的内容与 items 列表中的某个项是同一个对象。 这意味着关于该项本身的信息在两个地方产生了重复。简单的解决方法是消除重复项，使用 index 创建索引。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [selectedIndex, setSelectedIndex] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>); <span class=\"comment\">// 正确做法，避免重复</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 深度嵌套的 state</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> initialTravelPlan = {</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">title</span>: <span class=\"string\">'(Root)'</span>,</span><br><span class=\"line\">  <span class=\"attr\">childPlaces</span>: [{</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Earth'</span>,</span><br><span class=\"line\">    <span class=\"attr\">childPlaces</span>: [{</span><br><span class=\"line\">      <span class=\"attr\">id</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">      <span class=\"attr\">title</span>: <span class=\"string\">'Africa'</span>,</span><br><span class=\"line\">      <span class=\"attr\">childPlaces</span>: [{</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'Botswana'</span>,</span><br><span class=\"line\">        <span class=\"attr\">childPlaces</span>: []</span><br><span class=\"line\">      }, {</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'Egypt'</span>,</span><br><span class=\"line\">        <span class=\"attr\">childPlaces</span>: []</span><br><span class=\"line\">      }, {</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'Kenya'</span>,</span><br><span class=\"line\">        <span class=\"attr\">childPlaces</span>: []</span><br><span class=\"line\">      }, {</span><br><span class=\"line\">        <span class=\"attr\">id</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">        <span class=\"attr\">title</span>: <span class=\"string\">'Madagascar'</span>,</span><br><span class=\"line\">        <span class=\"attr\">childPlaces</span>: []</span><br><span class=\"line\">      }]</span><br><span class=\"line\">    }]</span><br><span class=\"line\">  }]</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 这个 state 变量的结构很深。更新它需要多次嵌套的映射和过滤操作。更好的做法是使用扁平化的结构。</span></span><br><span class=\"line\"><span class=\"comment\">//不同于树状结构，每个节点的 place 都是一个包含 其子节点 的数组，你可以让每个节点的 place 作为数组保存 其子节点的 ID。然后存储一个节点 ID 与相应节点的映射关系。</span></span><br><span class=\"line\"><span class=\"comment\">// 扁平化后的 state</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> initialTravelPlan = {</span><br><span class=\"line\">  <span class=\"number\">0</span>: {</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'(Root)'</span>,</span><br><span class=\"line\">    <span class=\"attr\">childIds</span>: [<span class=\"number\">1</span>, <span class=\"number\">42</span>, <span class=\"number\">46</span>],</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"number\">1</span>: {</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Earth'</span>,</span><br><span class=\"line\">    <span class=\"attr\">childIds</span>: [<span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">19</span>, <span class=\"number\">26</span>, <span class=\"number\">34</span>]</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"number\">2</span>: {</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Africa'</span>,</span><br><span class=\"line\">    <span class=\"attr\">childIds</span>: [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> , <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">  }, </span><br><span class=\"line\">  <span class=\"number\">3</span>: {</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Botswana'</span>,</span><br><span class=\"line\">    <span class=\"attr\">childIds</span>: []</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"number\">4</span>: {</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">4</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Egypt'</span>,</span><br><span class=\"line\">    <span class=\"attr\">childIds</span>: []</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"number\">5</span>: {</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">5</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Kenya'</span>,</span><br><span class=\"line\">    <span class=\"attr\">childIds</span>: []</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"number\">6</span>: {</span><br><span class=\"line\">    <span class=\"attr\">id</span>: <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"attr\">title</span>: <span class=\"string\">'Madagascar'</span>,</span><br><span class=\"line\">    <span class=\"attr\">childIds</span>: []</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 说明：由于原例代码过长，仅展示部分，以演示效果</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h3 id=\"useState-的使用\"><a href=\"#useState-的使用\" class=\"headerlink\" title=\"useState 的使用\"></a>useState 的使用</h3><h4 id=\"为组件添加状态\"><a href=\"#为组件添加状态\" class=\"headerlink\" title=\"为组件添加状态\"></a>为组件添加状态</h4><p>在组件的顶层调用 <code>useState</code> 来声明一个或多个状态变量。React 会存储新状态，使用新值重新渲染组件，并更新 UI。</p>\n<h4 id=\"根据先前的-state-更新-state\"><a href=\"#根据先前的-state-更新-state\" class=\"headerlink\" title=\"根据先前的 state 更新 state\"></a>根据先前的 state 更新 state</h4><p>要想根据先前的 <code>state</code> 更新 <code>state</code>，你可以将一个函数作为 <code>nextState</code> 传递给 <code>set</code> 函数。这个函数会接收当前的 <code>state</code> 作为参数，并返回新的 <code>state</code>。这个函数称为<strong>更新函数</strong>。</p>\n<p>假设 <code>age</code> 为 <code>42</code>，点击事件触发三次 <code>set</code> 函数：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick1</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">setAge</span>(age + <span class=\"number\">1</span>); <span class=\"comment\">// setAge(42 + 1)</span></span><br><span class=\"line\">  <span class=\"title function_\">setAge</span>(age + <span class=\"number\">1</span>); <span class=\"comment\">// setAge(42 + 1)</span></span><br><span class=\"line\">  <span class=\"title function_\">setAge</span>(age + <span class=\"number\">1</span>); <span class=\"comment\">// setAge(42 + 1)</span></span><br><span class=\"line\">  <span class=\"comment\">// 结果：age = 43</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick2</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">setAge</span>(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span>); <span class=\"comment\">// setAge(42 =&gt; 43)</span></span><br><span class=\"line\">  <span class=\"title function_\">setAge</span>(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span>); <span class=\"comment\">// setAge(43 =&gt; 44)</span></span><br><span class=\"line\">  <span class=\"title function_\">setAge</span>(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a + <span class=\"number\">1</span>); <span class=\"comment\">// setAge(44 =&gt; 45)</span></span><br><span class=\"line\">  <span class=\"comment\">// 结果：age = 45</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// 应该使用下面示例的更新函数来确保每次更新都基于最新的 state。</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"更新状态中的对象和数组\"><a href=\"#更新状态中的对象和数组\" class=\"headerlink\" title=\"更新状态中的对象和数组\"></a>更新状态中的对象和数组</h4><p>你可以将对象和数组放入状态中。在 React 中，状态被认为是<strong>只读</strong>的，因此 你应该使用 <code>set</code> 函数<strong>替换</strong>它而不是简单使用 <code>=</code> 来改变现有对象。</p>\n<h4 id=\"避免重复创建初始状态\"><a href=\"#避免重复创建初始状态\" class=\"headerlink\" title=\"避免重复创建初始状态\"></a>避免重复创建初始状态</h4><p>React 只在初次渲染时保存初始状态，后续渲染时将其忽略。</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">TodoList</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [todos, setTodos] = <span class=\"title function_\">useState</span>(<span class=\"title function_\">createInitialTodos</span>());</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>尽管 <code>createInitialTodos()</code> 的结果仅用于初始渲染，但你仍然在每次渲染时调用此函数。如果它创建大数组或执行昂贵的计算，这可能会浪费资源。</p>\n<p>为了解决这个问题，你可以将它作为初始化函数传递给 useState：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">TodoList</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [todos, setTodos] = <span class=\"title function_\">useState</span>(createInitialTodos);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>请注意，你传递的是 <code>createInitialTodos</code> 函数本身，而不是 <code>createInitialTodos()</code> 调用该函数的结果。如果将函数传递给 <code>useState</code>，React 仅在初始化期间调用它。</p>\n<p>React 在<strong>开发模式</strong>下可能会调用你的初始化函数两次，以验证它们是否是<strong>纯函数</strong>。</p>\n<h4 id=\"使用-key-重置状态\"><a href=\"#使用-key-重置状态\" class=\"headerlink\" title=\"使用 key 重置状态\"></a>使用 key 重置状态</h4><p>你可以 通过向组件传递不同的 <code>key</code> 来重置组件的状态。在这个例子中，重置按钮改变 <code>version</code> 状态变量，我们将它作为一个 <code>key</code> 传递给 <code>Form</code> 组件。当 <code>key</code> 改变时，React 会从头开始重新创建 <code>Form</code> 组件（以及它的所有子组件），所以它的状态被重置了。</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { useState } <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">App</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [version, setVersion] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">handleReset</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"title function_\">setVersion</span>(version + <span class=\"number\">1</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{handleReset}</span>&gt;</span>Reset<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">Form</span> <span class=\"attr\">key</span>=<span class=\"string\">{version}</span> /&gt;</span> {/* key 变化时，Form 组件会被重新创建 */}</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"存储前一次渲染的信息\"><a href=\"#存储前一次渲染的信息\" class=\"headerlink\" title=\"存储前一次渲染的信息\"></a>存储前一次渲染的信息</h4><p>通常情况下，你会在事件处理函数中更新状态。然而，在极少数情况下，你可能希望<strong>在响应渲染时调整状态</strong>——例如，当 <code>props</code> 改变时，你可能希望改变状态变量。</p>\n<p>在大多数情况下，你不需要这样做：</p>\n<ul>\n<li>如果你需要的值可以完全从当前 <code>props</code> 或其他 <code>state</code> 中<strong>计算</strong>出来，那么完全可以移除那些多余的状态。如果你担心重新计算的频率过高，可以使用 <code>useMemo</code> Hook 来帮助优化。</li>\n<li>如果你想<strong>重置</strong>整个组件树的状态，可以向组件传递一个不同的 <code>key</code>。</li>\n<li>如果可以的话，在事件处理函数中<strong>更新所有相关状态</strong>。</li>\n</ul>\n<p>在极为罕见的情况下，如果上述方法都不适用，你还可以使用一种方式，在组件渲染时调用 <code>set</code> 函数来基于已经渲染的值更新状态。</p>\n<h3 id=\"useState-疑难解答\"><a href=\"#useState-疑难解答\" class=\"headerlink\" title=\"useState 疑难解答\"></a>useState 疑难解答</h3><h4 id=\"我已经更新了状态，但日志仍显示旧值\"><a href=\"#我已经更新了状态，但日志仍显示旧值\" class=\"headerlink\" title=\"我已经更新了状态，但日志仍显示旧值\"></a>我已经更新了状态，但日志仍显示旧值</h4><p>调用 <code>set</code> 函数 不能改变运行中代码的状态：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count);  <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">setCount</span>(count + <span class=\"number\">1</span>); <span class=\"comment\">// 请求使用 1 重新渲染</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count);  <span class=\"comment\">// 仍然是 0!</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count); <span class=\"comment\">// 还是 0!</span></span><br><span class=\"line\">  }, <span class=\"number\">5000</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这是因为<strong>状态表现为就像一个快照</strong>。更新状态会使用新的状态值请求另一个渲染，但并不影响在你已经运行的事件处理函数中的 <code>count</code> JavaScript 变量。</p>\n<p>如果你需要使用下一个状态，你可以在将其传递给 <code>set</code> 函数之前将其保存在一个变量中：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nextCount = count + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"title function_\">setCount</span>(nextCount);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(count);     <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(nextCount); <span class=\"comment\">// 1</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"我已经更新了状态，但是屏幕没有更新\"><a href=\"#我已经更新了状态，但是屏幕没有更新\" class=\"headerlink\" title=\"我已经更新了状态，但是屏幕没有更新\"></a>我已经更新了状态，但是屏幕没有更新</h4><p>如果<strong>下一个状态等于先前的状态</strong>，React 将忽略你的更新。</p>\n<p>如果你修改了一个现有的 <code>obj</code> 对象并将其传递回 <code>setObj</code>，因此 React 忽略了更新。为了解决这个问题，你需要确保始终在状态中<strong>替换</strong>对象和数组，而不是对它们进行<strong>更改</strong>。</p>\n<h4 id=\"出现错误：“Too-many-re-renders”\"><a href=\"#出现错误：“Too-many-re-renders”\" class=\"headerlink\" title=\"出现错误：“Too many re-renders”\"></a>出现错误：“Too many re-renders”</h4><p>React 会限制渲染次数，以防止进入<strong>无限循环</strong>。通常，这意味着<strong>在渲染期间无条件地设置状态</strong>，因此组件进入循环：渲染、设置状态（导致重新渲染）、渲染、设置状态（导致重新渲染）等等。通常，这是由错误地指定事件处理函数时引起的：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 🚩 错误：在渲染过程中调用事件处理函数</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{handleClick()}</span>&gt;</span>Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ✅ 正确：将事件处理函数传递下去</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{handleClick}</span>&gt;</span>Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ✅ 正确：传递一个内联函数</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{(e)</span> =&gt;</span> handleClick(e)}&gt;Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果找不到这个错误的原因，请通过浏览器的检查工具，单击<strong>控制台</strong>中错误旁边的箭头，查看 <strong>JavaScript 堆栈</strong>以找到导致错误的具体 <code>set</code> 函数调用。</p>\n<h4 id=\"初始化函数或更新函数运行了两次\"><a href=\"#初始化函数或更新函数运行了两次\" class=\"headerlink\" title=\"初始化函数或更新函数运行了两次\"></a>初始化函数或更新函数运行了两次</h4><p>在<strong>严格模式</strong>下，React 会调用你的某些函数两次而不是一次，以帮助你发现意外的不纯性。您应该保证初始化函数、更新函数和组件函数是<strong>纯函数</strong>。</p>\n<p>事件处理函数不需要是纯粹的，所以 React 不会两次调用你的事件处理函数。</p>\n<h4 id=\"我尝试将-state-设置为一个函数，但它却被调用了\"><a href=\"#我尝试将-state-设置为一个函数，但它却被调用了\" class=\"headerlink\" title=\"我尝试将 state 设置为一个函数，但它却被调用了\"></a>我尝试将 state 设置为一个函数，但它却被调用了</h4><p>您不能像这样把函数放入状态：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [fn, setFn] = <span class=\"title function_\">useState</span>(someFunction);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">setFn</span>(someOtherFunction);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为你传递了一个函数，React 认为 <code>someFunction</code> 是一个<strong>初始化函数</strong>，而 <code>someOtherFunction</code> 是一个<strong>更新函数</strong>，于是它尝试调用它们并存储结果。要实际存储一个函数，你必须在两种情况下在它们之前加上 <code>() =&gt;</code>。然后 React 将存储你传递的函数。</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [fn, setFn] = <span class=\"title function_\">useState</span>(<span class=\"function\">() =&gt;</span> someFunction);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">setFn</span>(<span class=\"function\">() =&gt;</span> someOtherFunction);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<hr>\n<h2 id=\"二、useReducer\"><a href=\"#二、useReducer\" class=\"headerlink\" title=\"二、useReducer\"></a>二、useReducer</h2><h3 id=\"引入-useReducer\"><a href=\"#引入-useReducer\" class=\"headerlink\" title=\"引入 useReducer\"></a>引入 useReducer</h3><p>对于拥有许多状态更新逻辑的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以将组件的所有状态更新逻辑<strong>整合</strong>到一个<strong>外部函数</strong>中，这个函数叫作 <code>reducer</code>。</p>\n<h4 id=\"为什么称之为-reducer？\"><a href=\"#为什么称之为-reducer？\" class=\"headerlink\" title=\"为什么称之为 reducer？\"></a>为什么称之为 reducer？</h4><p>它实际上是以数组上的 reduce() 方法命名的。reduce() 允许你将数组中的多个值 “累加” 成一个值：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> sum = arr.<span class=\"title function_\">reduce</span>(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">result, number</span>) =&gt;</span> result + number</span><br><span class=\"line\">); <span class=\"comment\">// 1 + 2 + 3 + 4 + 5</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>你传递给 <code>reduce</code> 的函数被称为 “reducer”。它接受 <strong>目前的结果</strong> 和 <strong>当前的值</strong>，然后返回 <strong>下一个结果</strong>。React 中的 <code>reducer</code> 和这个是一样的：它们都接受 <strong>目前的状态</strong> 和 <strong>action</strong> ，然后返回 <strong>下一个状态</strong>。这样，<code>action</code> 会随着时间推移累积到状态中。</p>\n<p><code>useReducer</code> 是一个 React Hook，它允许你向组件里面添加一个 <code>reducer</code>。它是处理状态的另一种方式。你可以通过三个步骤将 <code>useState</code> 迁移到 <code>useReducer</code>：</p>\n<ol>\n<li>将设置状态的逻辑 <strong>修改</strong> 成 <code>dispatch</code> 的一个 <code>action</code>；</li>\n<li><strong>编写</strong> 一个 <code>reducer</code> 函数；</li>\n<li>在你的组件中 <strong>使用</strong> <code>reducer</code>。</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, { useReducer } <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> [state, dispatch] = <span class=\"title function_\">useReducer</span>(reducer, initialArg, init?);</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"dispatch-函数\"><a href=\"#dispatch-函数\" class=\"headerlink\" title=\"dispatch 函数\"></a>dispatch 函数</h4><p><code>useReducer</code> 返回的 <code>dispatch</code> 函数允许你更新 <code>state</code> 并触发组件的重新渲染。它需要传入一个 <code>action</code> 作为参数：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [state, dispatch] = <span class=\"title function_\">useReducer</span>(reducer, { <span class=\"attr\">age</span>: <span class=\"number\">42</span> });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'incremented_age'</span> });</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>React 会调用 <code>reducer</code> 函数以更新 <code>state</code>，<code>reducer</code> 函数的参数为当前的 <code>state</code> 与传递的 <code>action</code>。</p>\n<p><strong>参数：</strong></p>\n<ul>\n<li><code>action</code>：用户执行的操作。可以是任意类型的值。通常来说 <code>action</code> 是一个<strong>对象</strong>，其中 <code>type</code> 属性标识类型，其它属性携带额外信息。</li>\n</ul>\n<p><strong>返回值：</strong></p>\n<p><code>dispatch</code> 函数没有返回值。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li><code>dispatch</code> 函数是<strong>为下一次渲染而更新 state</strong>。因此在调用 dispatch 函数后读取 state <strong>并不会拿到更新后的值</strong>，也就是说只能获取到调用前的值。</li>\n<li>如果你提供的新值与当前的 <code>state</code> <strong>相同</strong>（使用 Object.is 比较），React 会<strong>跳过组件和子组件的重新渲染</strong>，这是一种优化手段。虽然在跳过重新渲染前 React 可能会调用你的组件，但是这不应该影响你的代码。</li>\n<li>React 会<strong>批量更新</strong> <code>state</code>。state 会在 <strong>所有事件函数执行完毕</strong> 并且已经调用过它的 <code>set</code> 函数后进行更新，这可以防止在一个事件中多次进行重新渲染。如果在访问 DOM 等极少数情况下需要强制 React 提前更新，可以使用 <code>flushSync</code>。</li>\n</ul>\n<h3 id=\"使用-useReducer\"><a href=\"#使用-useReducer\" class=\"headerlink\" title=\"使用 useReducer\"></a>使用 useReducer</h3><p>这一部分将以下面的代码为例进行说明：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { useState } <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">AddTask</span> <span class=\"keyword\">from</span> <span class=\"string\">'./AddTask.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">TaskList</span> <span class=\"keyword\">from</span> <span class=\"string\">'./TaskList.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">TaskApp</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [tasks, setTasks] = <span class=\"title function_\">useState</span>(initialTasks); <span class=\"comment\">// tasks 逻辑较为复杂</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">handleAddTask</span>(<span class=\"params\">text</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">setTasks</span>([</span><br><span class=\"line\">      ...tasks,</span><br><span class=\"line\">      {</span><br><span class=\"line\">        <span class=\"attr\">id</span>: nextId++,</span><br><span class=\"line\">        <span class=\"attr\">text</span>: text,</span><br><span class=\"line\">        <span class=\"attr\">done</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      },</span><br><span class=\"line\">    ]);</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">handleChangeTask</span>(<span class=\"params\">task</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">setTasks</span>(</span><br><span class=\"line\">      tasks.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">t</span>) =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.<span class=\"property\">id</span> === task.<span class=\"property\">id</span>) {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> task;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        }</span><br><span class=\"line\">      })</span><br><span class=\"line\">    );</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">handleDeleteTask</span>(<span class=\"params\">taskId</span>) {</span><br><span class=\"line\">    <span class=\"title function_\">setTasks</span>(tasks.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">t</span>) =&gt;</span> t.<span class=\"property\">id</span> !== taskId));</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>布拉格的行程安排<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">AddTask</span> <span class=\"attr\">onAddTask</span>=<span class=\"string\">{handleAddTask}</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">TaskList</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">tasks</span>=<span class=\"string\">{tasks}</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">onChangeTask</span>=<span class=\"string\">{handleChangeTask}</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">onDeleteTask</span>=<span class=\"string\">{handleDeleteTask}</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> nextId = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> initialTasks = [</span><br><span class=\"line\">  {<span class=\"attr\">id</span>: <span class=\"number\">0</span>, <span class=\"attr\">text</span>: <span class=\"string\">'参观卡夫卡博物馆'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span>},</span><br><span class=\"line\">  {<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">text</span>: <span class=\"string\">'看木偶戏'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">false</span>},</span><br><span class=\"line\">  {<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">text</span>: <span class=\"string\">'打卡列侬墙'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">false</span>},</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"第一步：将设置状态的逻辑修改成-dispatch-的一个-action\"><a href=\"#第一步：将设置状态的逻辑修改成-dispatch-的一个-action\" class=\"headerlink\" title=\"第一步：将设置状态的逻辑修改成 dispatch 的一个 action\"></a>第一步：将设置状态的逻辑修改成 dispatch 的一个 action</h4><p>移除所有的状态设置逻辑。只留下三个事件处理函数：</p>\n<ul>\n<li><code>handleAddTask(text)</code> 在用户点击 “添加” 时被调用。</li>\n<li><code>handleChangeTask(task)</code> 在用户切换任务或点击 “保存” 时被调用。</li>\n<li><code>handleDeleteTask(taskId)</code> 在用户点击 “删除” 时被调用。</li>\n</ul>\n<p>使用 <code>reducer</code> 管理状态与直接设置状态略有不同。它不是通过设置状态来告诉 React “<strong>要做什么</strong>”，而是通过事件处理程序 <code>dispatch</code> 一个 “action” 来指明 “<strong>用户刚刚做了什么</strong>”。（而状态更新逻辑则保存在其他地方！）因此，我们不再通过事件处理器直接 “设置 task”，而是 <code>dispatch</code> 一个 “添加/修改/删除任务” 的 <code>action</code>。这更加符合用户的思维。</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleAddTask</span>(<span class=\"params\">text</span>) {</span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>({</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">'added'</span>,</span><br><span class=\"line\">    <span class=\"attr\">id</span>: nextId++,</span><br><span class=\"line\">    <span class=\"attr\">text</span>: text,</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleChangeTask</span>(<span class=\"params\">task</span>) {</span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>({</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">'changed'</span>,</span><br><span class=\"line\">    <span class=\"attr\">task</span>: task,</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleDeleteTask</span>(<span class=\"params\">taskId</span>) {</span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>({</span><br><span class=\"line\">    <span class=\"attr\">type</span>: <span class=\"string\">'deleted'</span>,</span><br><span class=\"line\">    <span class=\"attr\">id</span>: taskId,</span><br><span class=\"line\">  });</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>你传递给 <code>dispatch</code> 的对象叫做 “action”。它是一个普通的 JavaScript 对象。它的结构是由你决定的，但通常来说，它应该至少包含可以表明 <strong>发生了什么事情</strong> 的信息。</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleDeleteTask</span>(<span class=\"params\">taskId</span>) {</span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>(</span><br><span class=\"line\">    <span class=\"comment\">// \"action\" 对象：</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">      <span class=\"attr\">type</span>: <span class=\"string\">'deleted'</span>,</span><br><span class=\"line\">      <span class=\"attr\">id</span>: taskId,</span><br><span class=\"line\">    }</span><br><span class=\"line\">  );</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"第二步：编写一个-reducer-函数\"><a href=\"#第二步：编写一个-reducer-函数\" class=\"headerlink\" title=\"第二步：编写一个 reducer 函数\"></a>第二步：编写一个 reducer 函数</h4><p>reducer 函数就是你放置状态逻辑的地方。它接受两个参数，分别为当前 state 和 action 对象，并且返回的是更新后的 state：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">yourReducer</span>(<span class=\"params\">state, action</span>) {</span><br><span class=\"line\">  <span class=\"comment\">// 给 React 返回更新后的状态</span></span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>React 会将状态设置为你从 <code>reducer</code> 返回的状态。</p>\n<p>在这个例子中，要将状态设置逻辑从事件处理程序移到 <code>reducer</code> 函数中，你需要：</p>\n<ol>\n<li>声明当前状态（tasks）作为第一个参数；</li>\n<li>声明 action 对象作为第二个参数；</li>\n<li>从 reducer 返回 下一个 状态（React 会将旧的状态设置为这个最新的状态）。</li>\n</ol>\n<p>下面是所有迁移到 reducer 函数的状态设置逻辑：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">tasksReducer</span>(<span class=\"params\">tasks, action</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.<span class=\"property\">type</span>) { <span class=\"comment\">// 使用 if-else 或 switch-case 均可，但后者是一般惯例</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'added'</span>: {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...tasks,</span><br><span class=\"line\">        {</span><br><span class=\"line\">          <span class=\"attr\">id</span>: action.<span class=\"property\">id</span>,</span><br><span class=\"line\">          <span class=\"attr\">text</span>: action.<span class=\"property\">text</span>,</span><br><span class=\"line\">          <span class=\"attr\">done</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        },</span><br><span class=\"line\">      ];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'changed'</span>: {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> tasks.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">t</span>) =&gt;</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.<span class=\"property\">id</span> === action.<span class=\"property\">task</span>.<span class=\"property\">id</span>) {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> action.<span class=\"property\">task</span>;</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">          <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">        }</span><br><span class=\"line\">      });</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'deleted'</span>: {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> tasks.<span class=\"title function_\">filter</span>(<span class=\"function\">(<span class=\"params\">t</span>) =&gt;</span> t.<span class=\"property\">id</span> !== action.<span class=\"property\">id</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"attr\">default</span>: {</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'未知 action: '</span> + action.<span class=\"property\">type</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>由于 <code>reducer</code> 函数接受 <code>state（tasks）</code>作为参数，因此你可以 <strong>在组件之外声明它</strong>。这减少了代码的缩进级别，提升了代码的可读性。</p>\n<h4 id=\"第三步：在组件中使用-reducer\"><a href=\"#第三步：在组件中使用-reducer\" class=\"headerlink\" title=\"第三步：在组件中使用 reducer\"></a>第三步：在组件中使用 reducer</h4><p>最后，你需要将 <code>tasksReducer</code> 导入到组件中。记得先从 React 中导入 <code>useReducer Hook</code>：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> { useReducer } <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br></pre></td></tr></tbody></table></figure>\n\n<p>接下来，你就可以替换掉之前的 <code>useState</code>:</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// const [tasks, setTasks] = useState(initialTasks);</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> [tasks, dispatch] = <span class=\"title function_\">useReducer</span>(tasksReducer, initialTasks);</span><br></pre></td></tr></tbody></table></figure>\n\n<p><code>useReducer</code> 和 <code>useState</code> 很相似——你必须给它传递一个初始状态，它会返回一个有状态的值和一个设置该状态的函数（在这个例子中就是 dispatch 函数）。但是，它们两个之间还是有点差异的。</p>\n<h4 id=\"对比-useState-和-useReducer\"><a href=\"#对比-useState-和-useReducer\" class=\"headerlink\" title=\"对比 useState 和 useReducer\"></a>对比 useState 和 useReducer</h4><p>Reducer 并非没有缺点！以下是比较它们的几种方法：</p>\n<ul>\n<li><strong>代码体积</strong>： 通常，在使用 <code>useState</code> 时，一开始只需要编写少量代码。而 <code>useReducer</code> 必须提前编写 <code>reducer</code> 函数和需要调度的 <code>actions</code>。但是，当多个事件处理程序以相似的方式修改 <code>state</code> 时，<code>useReducer</code> 可以减少代码量。</li>\n<li><strong>可读性</strong>： 当状态更新逻辑足够简单时，<code>useState</code> 的可读性还行。但是，一旦逻辑变得复杂起来，它们会使组件变得臃肿且难以阅读。在这种情况下，<code>useReducer</code> 允许你将状态更新逻辑与事件处理程序分离开来。</li>\n<li><strong>可调试性</strong>： 当使用 <code>useState</code> 出现问题时, 你很难发现具体原因以及为什么。 而使用 <code>useReducer</code> 时， 你可以在 <code>reducer</code> 函数中通过打印日志的方式来观察每个状态的更新，以及为什么要更新（来自哪个 <code>action</code>）。 如果所有 <code>action</code> 都没问题，你就知道问题出在了 <code>reducer</code> 本身的逻辑中。 然而，与使用 <code>useState</code> 相比，你必须单步执行更多的代码。</li>\n<li><strong>可测试性</strong>： <code>reducer</code> 是一个不依赖于组件的纯函数。这就意味着你可以单独对它进行测试。一般来说，我们最好是在真实环境中测试组件，但对于复杂的状态更新逻辑，针对特定的初始状态和 <code>action</code>，断言 <code>reducer</code> 返回的特定状态会很有帮助。</li>\n<li><strong>个人偏好</strong>： 并不是所有人都喜欢用 <code>reducer</code>，没关系，这是个人偏好问题。你可以随时在 <code>useState</code> 和 <code>useReducer</code> 之间切换，它们能做的事情是一样的！</li>\n</ul>\n<p>如果你在修改某些组件状态时经常出现问题或者想给组件添加更多逻辑时，我们建议你还是使用 <code>reducer</code>。当然，你也不必整个项目都用 <code>reducer</code>，这是可以自由搭配的。你甚至可以在一个组件中同时使用 <code>useState</code> 和 <code>useReducer</code>。</p>\n<h4 id=\"编写一个好的-reducer\"><a href=\"#编写一个好的-reducer\" class=\"headerlink\" title=\"编写一个好的 reducer\"></a>编写一个好的 reducer</h4><p>编写 reducer 时最好牢记以下两点：</p>\n<ul>\n<li>reducer 必须是纯粹的。 这一点和 状态更新函数 是相似的，reducer 是在渲染时运行的！（actions 会排队直到下一次渲染)。 这就意味着 reducer 必须纯净，即当输入相同时，输出也是相同的。它们不应该包含异步请求、定时器或者任何副作用（对组件外部有影响的操作）。它们应该以不可变值的方式去更新 对象 和 数组。</li>\n<li>每个 action 都描述了一个单一的用户交互，即使它会引发数据的多个变化。 举个例子，如果用户在一个由 reducer 管理的表单（包含五个表单项）中点击了 重置按钮，那么 dispatch 一个 reset_form 的 action 比 dispatch 五个单独的 set_field 的 action 更加合理。如果你在一个 reducer 中打印了所有的 action 日志，那么这个日志应该是很清晰的，它能让你以某种步骤复现已发生的交互或响应。这对代码调试很有帮助！</li>\n</ul>\n<h4 id=\"使用-Immer-简化-reducer\"><a href=\"#使用-Immer-简化-reducer\" class=\"headerlink\" title=\"使用 Immer 简化 reducer\"></a>使用 Immer 简化 reducer</h4><p>与在平常的 <code>state</code> 中修改对象和数组一样，你可以使用 <strong>Immer</strong> 这个库来简化 <code>reducer</code>。在这里，<code>useImmerReducer</code> 让你可以通过 <code>push</code> 或 <code>arr[i] =</code> 来修改 <code>state</code> 。</p>\n<p><code>Reducer</code> 应该是纯净的，所以它们不应该去修改 <code>state</code>。而 Immer 为你提供了一种特殊的 <code>draft</code> 对象，你可以通过它安全地修改 <code>state</code>。在底层，Immer 会基于当前 <code>state</code> 创建一个副本。这就是通过 <code>useImmerReducer</code> 来管理 <code>reduce</code>r 时，可以修改第一个参数，且不需要返回一个新的 <code>state</code> 的原因。</p>\n<h3 id=\"useReducer-疑难解答\"><a href=\"#useReducer-疑难解答\" class=\"headerlink\" title=\"useReducer 疑难解答\"></a>useReducer 疑难解答</h3><h4 id=\"我已经-dispatch-了一个-action，但是打印出来仍然还是旧的-state\"><a href=\"#我已经-dispatch-了一个-action，但是打印出来仍然还是旧的-state\" class=\"headerlink\" title=\"我已经 dispatch 了一个 action，但是打印出来仍然还是旧的 state\"></a>我已经 dispatch 了一个 action，但是打印出来仍然还是旧的 state</h4><p>调用 <code>dispatch</code> 函数 不会改变当前渲染的 <code>state</code>：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">handleClick</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state.<span class=\"property\">age</span>);  <span class=\"comment\">// 42</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">dispatch</span>({ <span class=\"attr\">type</span>: <span class=\"string\">'incremented_age'</span> }); <span class=\"comment\">// 用 43 进行重新渲染</span></span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state.<span class=\"property\">age</span>);  <span class=\"comment\">// 还是 42！</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state.<span class=\"property\">age</span>); <span class=\"comment\">// 一样是 42！</span></span><br><span class=\"line\">  }, <span class=\"number\">5000</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>这是因为 <code>state</code> 的行为和<strong>快照</strong>一样。更新 <code>state</code> 会使用新的值来对组件进行重新渲染，但是不会改变当前执行的事件处理函数里面 <code>state</code> 的值。</p>\n<p>如果你需要获取更新后的 <code>state</code>，可以手动调用 <code>reducer</code> 来得到结果：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> action = { <span class=\"attr\">type</span>: <span class=\"string\">'incremented_age'</span> };</span><br><span class=\"line\"><span class=\"title function_\">dispatch</span>(action);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> nextState = <span class=\"title function_\">reducer</span>(state, action);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(state);     <span class=\"comment\">// { age: 42 }</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(nextState); <span class=\"comment\">// { age: 43 }</span></span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"我已经-dispatch-了一个-action，但是屏幕并没有更新\"><a href=\"#我已经-dispatch-了一个-action，但是屏幕并没有更新\" class=\"headerlink\" title=\"我已经 dispatch 了一个 action，但是屏幕并没有更新\"></a>我已经 dispatch 了一个 action，但是屏幕并没有更新</h4><p>React 使用 Object.is 比较更新前后的 <code>state</code>，如果 它们相等就会跳过这次更新。这通常是因为你<strong>直接修改了对象或数组</strong>：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reducer</span>(<span class=\"params\">state, action</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.<span class=\"property\">type</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'incremented_age'</span>: {</span><br><span class=\"line\">      <span class=\"comment\">// 🚩 错误行为：直接修改对象</span></span><br><span class=\"line\">      state.<span class=\"property\">age</span>++;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'changed_name'</span>: {</span><br><span class=\"line\">      <span class=\"comment\">// 🚩 错误行为：直接修改对象</span></span><br><span class=\"line\">      state.<span class=\"property\">name</span> = action.<span class=\"property\">nextName</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>你直接修改并返回了一个 <code>state</code> 对象，所以 React 会跳过这次更新。为了修复这个错误，你应该确保总是 <strong>使用正确的方式更新对象和数组</strong>：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reducer</span>(<span class=\"params\">state, action</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.<span class=\"property\">type</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'incremented_age'</span>: {</span><br><span class=\"line\">      <span class=\"comment\">// ✅ 修复：创建一个新的对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> {</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        <span class=\"attr\">age</span>: state.<span class=\"property\">age</span> + <span class=\"number\">1</span></span><br><span class=\"line\">      };</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'changed_name'</span>: {</span><br><span class=\"line\">      <span class=\"comment\">// ✅ 修复：创建一个新的对象</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> {</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        <span class=\"attr\">name</span>: action.<span class=\"property\">nextName</span></span><br><span class=\"line\">      };</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<h4 id=\"在-dispatch-后-state-的某些属性变为了-undefined\"><a href=\"#在-dispatch-后-state-的某些属性变为了-undefined\" class=\"headerlink\" title=\"在 dispatch 后 state 的某些属性变为了 undefined\"></a>在 dispatch 后 state 的某些属性变为了 undefined</h4><p>请确保每个 <code>case</code> 语句中所返回的新的 <code>state</code> 都复制了当前的属性：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reducer</span>(<span class=\"params\">state, action</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.<span class=\"property\">type</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'incremented_age'</span>: {</span><br><span class=\"line\">      <span class=\"keyword\">return</span> {</span><br><span class=\"line\">        ...state, <span class=\"comment\">// 不要忘记复制之前的属性！</span></span><br><span class=\"line\">        <span class=\"attr\">age</span>: state.<span class=\"property\">age</span> + <span class=\"number\">1</span></span><br><span class=\"line\">      };</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果上面的代码没有 <code>...state</code> ，返回的新的 <code>state</code> 就只有 <code>age</code> 属性。</p>\n<h4 id=\"在-dispatch-后整个-state-都变为了-undefined\"><a href=\"#在-dispatch-后整个-state-都变为了-undefined\" class=\"headerlink\" title=\"在 dispatch 后整个 state 都变为了 undefined\"></a>在 dispatch 后整个 state 都变为了 undefined</h4><p>如果你的 <code>state</code> 错误地变成了 <code>undefined</code>，可能是因为你忘记在某个分支返回 <code>state</code>，或者是你遗漏了某些 <code>case</code> 分支。可以通过在 <code>switch</code> 语句之后抛出一个错误来查找原因：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reducer</span>(<span class=\"params\">state, action</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.<span class=\"property\">type</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'incremented_age'</span>: {</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'edited_name'</span>: {</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"title class_\">Error</span>(<span class=\"string\">'Unknown action: '</span> + action.<span class=\"property\">type</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>也可以通过使用 TypeScript 等静态检查工具来发现这类错误。</p>\n<h4 id=\"我收到了一个报错：“Too-many-re-renders”\"><a href=\"#我收到了一个报错：“Too-many-re-renders”\" class=\"headerlink\" title=\"我收到了一个报错：“Too many re-renders”\"></a>我收到了一个报错：“Too many re-renders”</h4><p>这通常是在 <strong>渲染期间  dispatch 了 action</strong> 而导致组件进入了<strong>无限循环</strong>：dispatch（会导致一次重新渲染）、渲染、dispatch（再次导致重新渲染），然后无限循环。大多数这样的错误是由于<strong>事件处理函数</strong>中存在错误的逻辑：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 🚩 错误：渲染期间调用了处理函数</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{handleClick()}</span>&gt;</span>Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ✅ 修复：传递一个处理函数，而不是调用</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{handleClick}</span>&gt;</span>Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// ✅ 修复：传递一个内联的箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">{(e)</span> =&gt;</span> handleClick(e)}&gt;Click me<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>\n\n<p>如果你没有发现上述错误，在控制台点开报错旁边的箭头以查看<strong>错误堆栈</strong>，从中查找是哪个 <code>dispatch</code> 函数引发的错误。</p>\n<h4 id=\"我的-reducer-和初始化函数运行了两次\"><a href=\"#我的-reducer-和初始化函数运行了两次\" class=\"headerlink\" title=\"我的 reducer 和初始化函数运行了两次\"></a>我的 reducer 和初始化函数运行了两次</h4><p><strong>严格模式</strong> 下 React 会调用两次 <code>reducer</code> 和初始化函数，但是这不应该会破坏你的代码逻辑。</p>\n<p>这个 <strong>仅限于开发模式</strong> 的行为可以帮助你 <strong>保持组件纯粹</strong>：React 会使用其中一次调用结果并忽略另一个结果。如果你的<strong>组件、初始化函数以及 reducer 函数</strong>都是纯函数，这并不会影响你的逻辑。不过一旦它们存在副作用，这个额外的行为就可以帮助你发现它。</p>\n<p>比如下面这个 <code>reducer</code> 函数直接修改了数组类型的 <code>state</code>：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reducer</span>(<span class=\"params\">state, action</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.<span class=\"property\">type</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'added_todo'</span>: {</span><br><span class=\"line\">      <span class=\"comment\">// 🚩 错误：直接修改 state</span></span><br><span class=\"line\">      state.<span class=\"property\">todos</span>.<span class=\"title function_\">push</span>({ <span class=\"attr\">id</span>: nextId++, <span class=\"attr\">text</span>: action.<span class=\"property\">text</span> });</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>因为 React 会调用 <code>reducer</code> 函数两次，导致你看到添加了两条代办事项，于是你就发现了这个错误行为。在这个示例中，你可以通过 <strong>返回新的数组而不是修改数组</strong> 来修复它：</p>\n<figure class=\"highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">reducer</span>(<span class=\"params\">state, action</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.<span class=\"property\">type</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'added_todo'</span>: {</span><br><span class=\"line\">      <span class=\"comment\">// ✅ 修复：返回一个新的 state 数组</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> {</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        <span class=\"attr\">todos</span>: [</span><br><span class=\"line\">          ...state.<span class=\"property\">todos</span>,</span><br><span class=\"line\">          { <span class=\"attr\">id</span>: nextId++, <span class=\"attr\">text</span>: action.<span class=\"property\">text</span> }</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      };</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n\n<p>现在这个 <code>reducer</code> 是纯函数了，调用两次也不会有不一致的行为。事件处理函数不需要实现为纯函数，并且 React 永远不会调用事件函数两次。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>钩子函数是 React 16.8 版本引入的一个重要特性，它允许在函数组件中使用状态和其他 React 特性。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Hook 可以帮助在组件中使用不同的 React 功能。你可以使用内置的 Hook 或使用自定义 Hook。</p></blockquote>\n<p>此系列博客将对 React 钩子函数进行较为全面的整理，以及自定义钩子函数的写法与用途。主要将参考 React 官方文档、ChatGPT 或者 Copilot 补全以及B站或者油管上的视频。</p>\n<p>一方面本文档整合了官方文档中的多篇相关内容，避免您在频繁切换页面时思路混乱；另一方面，本文档也会对一些内容进行补充和扩展，以便您更好更全面地理解和使用这些钩子函数。</p>\n<p><code>useState</code> 和 <code>useReducer</code> 是两个常用的钩子函数，分别用于管理组件的状态和处理复杂的状态逻辑。</p>\n<p>参考文献：</p>\n<ul>\n<li><a href=\"https://zh-hans.react.dev/reference/react/hooks\">React 内置 Hook - React 中文文档</a></li>\n<li><a href=\"https://zh-hans.react.dev/reference/react/useState\">useState - React 中文文档</a></li>\n<li><a href=\"https://zh-hans.react.dev/reference/react/useReducer\">useReducer - React 中文文档</a></li>\n<li><a href=\"https://zh-hans.react.dev/learn/state-a-components-memory\">State：组件的记忆 - React 中文文档</a></li>\n<li><a href=\"https://zh-hans.react.dev/learn/render-and-commit\">渲染和提交 - React 中文文档</a></li>\n<li><a href=\"https://zh-hans.react.dev/learn/state-as-a-snapshot\">state 如同一张快照</a></li>\n<li><a href=\"https://zh-hans.react.dev/learn/choosing-the-state-structure\">选择 State 结构 - React 中文文档</a></li>\n<li><a href=\"https://zh-hans.react.dev/learn/sharing-state-between-components\">在组件间共享状态 - React 中文文档</a></li>\n<li><a href=\"https://zh-hans.react.dev/learn/preserving-and-resetting-state\">对 state 进行保留和重置 - React 中文文档</a></li>\n<li><a href=\"https://zh-hans.react.dev/learn/extracting-state-logic-into-a-reducer\">迁移状态逻辑至 Reducer 中 - React 中文文档</a></li>\n</ul>\n","text":"React钩子函数-1-useState和useReducer一、背景与概述这两个钩子函数归纳为 State Hook。 状态帮助组件 “记住”用户输入的信息。...","permalink":"/post/react-hook-1-usestate-usereducer","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[{"name":"前端","slug":"前端","count":19,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":19,"path":"api/tags/前端.json"},{"name":"技术","slug":"技术","count":17,"path":"api/tags/技术.json"},{"name":"笔记","slug":"笔记","count":10,"path":"api/tags/笔记.json"},{"name":"React","slug":"React","count":3,"path":"api/tags/React.json"},{"name":"钩子函数","slug":"钩子函数","count":2,"path":"api/tags/钩子函数.json"},{"name":"React Hook","slug":"React-Hook","count":1,"path":"api/tags/React-Hook.json"},{"name":"useState","slug":"useState","count":1,"path":"api/tags/useState.json"},{"name":"useReducer","slug":"useReducer","count":1,"path":"api/tags/useReducer.json"},{"name":"官方文档","slug":"官方文档","count":1,"path":"api/tags/官方文档.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#React%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-1-useState%E5%92%8CuseReducer\"><span class=\"toc-text\">React钩子函数-1-useState和useReducer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E8%83%8C%E6%99%AF%E4%B8%8E%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">一、背景与概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E5%92%8C%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">渲染和提交</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A4-1-%E8%A7%A6%E5%8F%91%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">步骤 1: 触发一次渲染</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">初次渲染</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">状态更新时重新渲染</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A4-2-React-%E6%B8%B2%E6%9F%93%E4%BD%A0%E7%9A%84%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">步骤 2: React 渲染你的组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A5%E9%AA%A4-3-React-%E6%8A%8A%E6%9B%B4%E6%94%B9%E6%8F%90%E4%BA%A4%E5%88%B0-DOM-%E4%B8%8A\"><span class=\"toc-text\">步骤 3: React 把更改提交到 DOM 上</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B0%BE%E5%A3%B0%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%98%E5%88%B6\"><span class=\"toc-text\">尾声：浏览器绘制</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81useState\"><span class=\"toc-text\">二、useState</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5-useState\"><span class=\"toc-text\">引入 useState</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#useState-initialState\"><span class=\"toc-text\">useState(initialState)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#set-%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BE%8B%E5%A6%82-setSomething-nextState\"><span class=\"toc-text\">set 函数，例如 setSomething(nextState)</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#state-%E7%9A%84%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">state 的特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#State-%E6%98%AF%E9%9A%94%E7%A6%BB%E4%B8%94%E7%A7%81%E6%9C%89%E7%9A%84\"><span class=\"toc-text\">State 是隔离且私有的</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#state-%E5%A6%82%E5%90%8C%E4%B8%80%E5%BC%A0%E5%BF%AB%E7%85%A7\"><span class=\"toc-text\">state 如同一张快照</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#state-%E7%9A%84%E2%80%9C%E6%89%B9%E5%A4%84%E7%90%86%E2%80%9D\"><span class=\"toc-text\">state 的“批处理”</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9-state-%E8%BF%9B%E8%A1%8C%E4%BF%9D%E7%95%99%E5%92%8C%E9%87%8D%E7%BD%AE\"><span class=\"toc-text\">对 state 进行保留和重置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#state-%E7%9A%84%E6%9E%84%E5%BB%BA%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">state 的构建原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useState-%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">useState 的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E7%BB%84%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">为组件添加状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%8D%AE%E5%85%88%E5%89%8D%E7%9A%84-state-%E6%9B%B4%E6%96%B0-state\"><span class=\"toc-text\">根据先前的 state 更新 state</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">更新状态中的对象和数组</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%88%9B%E5%BB%BA%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">避免重复创建初始状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-key-%E9%87%8D%E7%BD%AE%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">使用 key 重置状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%89%8D%E4%B8%80%E6%AC%A1%E6%B8%B2%E6%9F%93%E7%9A%84%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">存储前一次渲染的信息</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useState-%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94\"><span class=\"toc-text\">useState 疑难解答</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%91%E5%B7%B2%E7%BB%8F%E6%9B%B4%E6%96%B0%E4%BA%86%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BD%86%E6%97%A5%E5%BF%97%E4%BB%8D%E6%98%BE%E7%A4%BA%E6%97%A7%E5%80%BC\"><span class=\"toc-text\">我已经更新了状态，但日志仍显示旧值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%91%E5%B7%B2%E7%BB%8F%E6%9B%B4%E6%96%B0%E4%BA%86%E7%8A%B6%E6%80%81%EF%BC%8C%E4%BD%86%E6%98%AF%E5%B1%8F%E5%B9%95%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">我已经更新了状态，但是屏幕没有更新</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%EF%BC%9A%E2%80%9CToo-many-re-renders%E2%80%9D\"><span class=\"toc-text\">出现错误：“Too many re-renders”</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E6%88%96%E6%9B%B4%E6%96%B0%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E4%BA%86%E4%B8%A4%E6%AC%A1\"><span class=\"toc-text\">初始化函数或更新函数运行了两次</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%91%E5%B0%9D%E8%AF%95%E5%B0%86-state-%E8%AE%BE%E7%BD%AE%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BD%86%E5%AE%83%E5%8D%B4%E8%A2%AB%E8%B0%83%E7%94%A8%E4%BA%86\"><span class=\"toc-text\">我尝试将 state 设置为一个函数，但它却被调用了</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81useReducer\"><span class=\"toc-text\">二、useReducer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%95%E5%85%A5-useReducer\"><span class=\"toc-text\">引入 useReducer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A7%B0%E4%B9%8B%E4%B8%BA-reducer%EF%BC%9F\"><span class=\"toc-text\">为什么称之为 reducer？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#dispatch-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">dispatch 函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-useReducer\"><span class=\"toc-text\">使用 useReducer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%B0%86%E8%AE%BE%E7%BD%AE%E7%8A%B6%E6%80%81%E7%9A%84%E9%80%BB%E8%BE%91%E4%BF%AE%E6%94%B9%E6%88%90-dispatch-%E7%9A%84%E4%B8%80%E4%B8%AA-action\"><span class=\"toc-text\">第一步：将设置状态的逻辑修改成 dispatch 的一个 action</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-reducer-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">第二步：编写一个 reducer 函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8-reducer\"><span class=\"toc-text\">第三步：在组件中使用 reducer</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94-useState-%E5%92%8C-useReducer\"><span class=\"toc-text\">对比 useState 和 useReducer</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84-reducer\"><span class=\"toc-text\">编写一个好的 reducer</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Immer-%E7%AE%80%E5%8C%96-reducer\"><span class=\"toc-text\">使用 Immer 简化 reducer</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#useReducer-%E7%96%91%E9%9A%BE%E8%A7%A3%E7%AD%94\"><span class=\"toc-text\">useReducer 疑难解答</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%91%E5%B7%B2%E7%BB%8F-dispatch-%E4%BA%86%E4%B8%80%E4%B8%AA-action%EF%BC%8C%E4%BD%86%E6%98%AF%E6%89%93%E5%8D%B0%E5%87%BA%E6%9D%A5%E4%BB%8D%E7%84%B6%E8%BF%98%E6%98%AF%E6%97%A7%E7%9A%84-state\"><span class=\"toc-text\">我已经 dispatch 了一个 action，但是打印出来仍然还是旧的 state</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%91%E5%B7%B2%E7%BB%8F-dispatch-%E4%BA%86%E4%B8%80%E4%B8%AA-action%EF%BC%8C%E4%BD%86%E6%98%AF%E5%B1%8F%E5%B9%95%E5%B9%B6%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">我已经 dispatch 了一个 action，但是屏幕并没有更新</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8-dispatch-%E5%90%8E-state-%E7%9A%84%E6%9F%90%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%98%E4%B8%BA%E4%BA%86-undefined\"><span class=\"toc-text\">在 dispatch 后 state 的某些属性变为了 undefined</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8-dispatch-%E5%90%8E%E6%95%B4%E4%B8%AA-state-%E9%83%BD%E5%8F%98%E4%B8%BA%E4%BA%86-undefined\"><span class=\"toc-text\">在 dispatch 后整个 state 都变为了 undefined</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%91%E6%94%B6%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E6%8A%A5%E9%94%99%EF%BC%9A%E2%80%9CToo-many-re-renders%E2%80%9D\"><span class=\"toc-text\">我收到了一个报错：“Too many re-renders”</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%91%E7%9A%84-reducer-%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C%E4%BA%86%E4%B8%A4%E6%AC%A1\"><span class=\"toc-text\">我的 reducer 和初始化函数运行了两次</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">三、总结</span></a></li></ol></li></ol>","author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"JS高级-6-面向对象编程-2","uid":"b8c33cb7f848582aa7c9a297a62853e5","slug":"js-premier-6-object-oriented-programming-2","date":"2025-07-31T06:41:18.000Z","updated":"2025-08-25T14:15:33.318Z","comments":true,"path":"api/articles/js-premier-6-object-oriented-programming-2.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-js.png","text":"JS高级-5-面向对象编程-2一、原型链和继承面向对象的特性 封装（Encapsulation）：将数据（属性）和行为（方法）封装在一起，对外隐藏内部实现细节，...","permalink":"/post/js-premier-6-object-oriented-programming-2","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[{"name":"前端","slug":"前端","count":19,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":19,"path":"api/tags/前端.json"},{"name":"技术","slug":"技术","count":17,"path":"api/tags/技术.json"},{"name":"笔记","slug":"笔记","count":10,"path":"api/tags/笔记.json"},{"name":"JavaScript","slug":"JavaScript","count":7,"path":"api/tags/JavaScript.json"},{"name":"进阶","slug":"进阶","count":6,"path":"api/tags/进阶.json"},{"name":"面向对象编程","slug":"面向对象编程","count":2,"path":"api/tags/面向对象编程.json"},{"name":"OOP","slug":"OOP","count":2,"path":"api/tags/OOP.json"},{"name":"原型链","slug":"原型链","count":1,"path":"api/tags/原型链.json"},{"name":"继承","slug":"继承","count":1,"path":"api/tags/继承.json"},{"name":"类","slug":"类","count":1,"path":"api/tags/类.json"}],"author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"JS高级-5-面向对象编程-1","uid":"b3a5751f5eb5e3e9873a3f7c71f06e93","slug":"js-premier-5-object-oriented-programming-1","date":"2025-07-28T10:18:47.000Z","updated":"2025-08-24T18:28:56.294Z","comments":true,"path":"api/articles/js-premier-5-object-oriented-programming-1.json","keywords":null,"cover":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/cover-js.png","text":"JS高级-5-面向对象编程-1一、面向对象的理解面向对象是现实的抽象方式。对象是 JavaScript 中一个非常重要的概念，因为对象可以将多个相关联的数据封装...","permalink":"/post/js-premier-5-object-oriented-programming-1","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"前端","slug":"前端","count":19,"path":"api/categories/前端.json"}],"tags":[{"name":"前端","slug":"前端","count":19,"path":"api/tags/前端.json"},{"name":"技术","slug":"技术","count":17,"path":"api/tags/技术.json"},{"name":"笔记","slug":"笔记","count":10,"path":"api/tags/笔记.json"},{"name":"JavaScript","slug":"JavaScript","count":7,"path":"api/tags/JavaScript.json"},{"name":"进阶","slug":"进阶","count":6,"path":"api/tags/进阶.json"},{"name":"面向对象编程","slug":"面向对象编程","count":2,"path":"api/tags/面向对象编程.json"},{"name":"OOP","slug":"OOP","count":2,"path":"api/tags/OOP.json"},{"name":"原型","slug":"原型","count":1,"path":"api/tags/原型.json"},{"name":"构造函数","slug":"构造函数","count":1,"path":"api/tags/构造函数.json"}],"author":{"name":"Proselyte","slug":"blog-author","avatar":"https://raw.githubusercontent.com/ProselyteCoding/online-assets/main/blog/avatar.jpg","link":"/","description":"衷于创造，向往自由。","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}